{
  "en": {
    "ui": {
      "title": "Learn Git and GitHub",
      "subtitle": "Version control from zero — Essential for Digital Humanities",
      "welcome": "Welcome to Git and GitHub!",
      "welcomeDescription": "This interactive tutorial teaches version control from the ground up. No prior knowledge of Git, GitHub, or version control is assumed. You'll learn why these tools matter—especially for Digital Humanities projects—and how to use them. Everything is done in the terminal and file editor on this page: you do not need to use your computer's terminal or install Git.",
      "tutorialCredit": "This tutorial follows the same module system as the HTML/CSS course. It is available in English and French.",
      "enterName": "Enter your name",
      "chooseAvatar": "Choose your avatar",
      "chooseAvatarOption": "Avatar option {number} of {total}",
      "avatarPickerScrollHint": "Scroll for more avatars",
      "changeAvatar": "Change avatar",
      "startLearning": "Start Learning",
      "nameCertificateNote": "This name will appear on your shareable certificate when you complete all lessons.",
      "welcomeUser": "Welcome, {name}! • Lesson {current} of {total}",
      "courseProgress": "Course Progress - Click any section to jump to it",
      "whatWeLearning": "What we're learning:",
      "whyImportant": "Why it's important:",
      "needHint": "Need a hint? Click to see what to do",
      "hideHint": "Hide hint",
      "showHint": "Show hint",
      "whatToDo": "What to do:",
      "commandsToTry": "Command(s) to try",
      "copyCommand": "Copy command",
      "terminalHint": "Use the terminal on the right to run the command.",
      "terminalNavHint": "Commands: ls, pwd, cd, cat, echo, edit | git ... | next | back | clear",
      "editorLabel": "File editor",
      "save": "Save",
      "cancel": "Cancel",
      "back": "← Back",
      "verifyCode": "I've done this →",
      "skip": "Skip →",
      "tryAgain": "Try Again",
      "nextLesson": "Next Lesson →",
      "learnMore": "Learn more",
      "tip": "Tip:",
      "copyUrl": "Copy this URL to save your progress and resume later:",
      "noFilesSaved": "No data is saved on our server—this is the only way to re-access your progress.",
      "certificateTitle": "Certificate of Completion",
      "certificateSubtitle": "Git and GitHub for Version Control",
      "certificateDescription": "This certifies that",
      "certificateCompleted": "has successfully completed the interactive tutorial on version control, Git basics, and GitHub—with a focus on why these tools matter for Digital Humanities.",
      "certificateCovered": "This course covered:",
      "completedOn": "Completed on",
      "congratulations": "Congratulations",
      "certificateShare": "Share this certificate with anyone by copying the URL:",
      "certificateShareDescription": "You can copy the URL above to share your certificate.",
      "emailCertificate": "Email Certificate",
      "emailCertificateSubject": "Check out my certificate",
      "emailCertificateBody": "I've completed the Git and GitHub tutorial! Check out my certificate:",
      "certificateItem1": "What is version control and why it matters for Digital Humanities",
      "certificateItem2": "Git basics: repositories, commits, and history",
      "certificateItemBranching": "Branching: create branches, merge, squash, and rebase",
      "certificateItem3": "GitHub: hosting, push, pull, and clone",
      "certificateItem4": "Collaboration and good practices for DH projects",
      "successMessage": "Well done! Continue to the next lesson when ready.",
      "errorMessage": "Not quite right. Make sure you: {elements}",
      "selectLanguage": "Select language",
      "studentNameAria": "Student name: {name}",
      "completed": "Completed",
      "jumpToSection": "Jump to {section} section. {completed} of {total} lessons completed.",
      "hintRegion": "Hint instructions",
      "glossaryButton": "Glossary",
      "glossaryTitle": "Glossary",
      "glossarySearchPlaceholder": "Search terms...",
      "glossaryClose": "Close glossary",
      "glossaryNoResults": "No terms match your search.",
      "skipToMainContent": "Skip to main content",
      "definitionOf": "Definition of {term}",
      "backToLessons": "Back to lessons",
      "viewCertificate": "View certificate",
      "reportBug": "Report bug"
    },
    "categories": {
      "versionControl": "Version Control",
      "gitBasics": "Git Basics",
      "branching": "Branching",
      "github": "GitHub",
      "collaboration": "Collaboration"
    },
    "lessons": {
      "vc-1": {
        "title": "What is version control?",
        "description": "Version control is a way to save and track changes to your files over time. Instead of ending up with files like \"thesis_v1.docx\", \"thesis_final.docx\", and \"thesis_FINAL_really.docx\", you keep one project and a history of every change: who changed what, and when. You can go back to any earlier version if you need to.",
        "whyImportant": "Without version control, it's easy to lose work, overwrite someone else's changes, or forget what you changed. With it, you have a clear history and can collaborate safely. For Digital Humanities projects—editions, corpora, datasets, and websites—this is essential: you often work in teams, iterate over years, and need to cite or reproduce a specific state of the project.",
        "whatToDo": [
          "Read the explanation above",
          "Think of a project (e.g. a text edition or dataset) where you'd want to track every change",
          "In the terminal on the right, type **next** when you're ready to continue"
        ]
      },
      "vc-2": {
        "title": "Why version control matters for Digital Humanities",
        "description": "Digital Humanities projects usually involve texts, metadata, code, and often several people. Version control lets you: keep a single source of truth instead of scattered copies; see who added or changed which line; recover from mistakes; and give others (or future you) a way to understand and reproduce your work. Many funders and publishers now expect or recommend using version control for transparency and reproducibility.",
        "whyImportant": "DH work is research. Being able to show how a corpus or edition evolved, and to restore or cite a specific version, supports both scholarly practice and open science. Learning Git and GitHub is one of the most practical skills you can add to your DH toolkit.",
        "whatToDo": [
          "Read why DH projects benefit from version control",
          "In the terminal, type **next** to continue"
        ]
      },
      "git-1": {
        "title": "What is Git?",
        "description": "Git is a free, open-source tool that does version control on your computer. It was created to manage the Linux kernel source code and is now used worldwide. Git runs locally: it keeps the full history of your project in a hidden folder (a repository) inside your project. You don't need the internet to make commits—only when you want to share or back up with a server like GitHub. In this course we simulate Git in the terminal on this page—no installation needed.",
        "whyImportant": "Git is the standard for version control in software and in many DH projects. Understanding that Git is local-first (your history lives on your machine) helps you see why we later add GitHub for backup and collaboration.",
        "whatToDo": [
          "In the terminal on the right, type: **git --version**",
          "You'll see a simulated version. (On a real computer you'd install from https://git-scm.com/.)",
          "Type **next** when ready to continue"
        ],
        "codeTemplate": "git --version"
      },
      "git-2": {
        "title": "Your first repository: git init",
        "description": "A repository (or repo) is the folder where Git keeps the history of your project. To turn a folder into a Git repository, you run git init in that folder. Here, the terminal is already in a simulated project folder (~/my-project). After git init, Git will track changes to files when you tell it to.",
        "whyImportant": "Creating a repo is the first step to using Git. From here on, we'll add files and make commits inside this repo—all in the browser terminal.",
        "whatToDo": [
          "In the terminal, type: **git init**",
          "You should see \"Initialized empty Git repository in .git/\"",
          "The lesson completes automatically when you run the command"
        ],
        "codeTemplate": "git init"
      },
      "git-3": {
        "title": "Staging and committing: git add and git commit",
        "description": "Git doesn't save every change automatically. You choose which changes to include in a \"commit\" (a snapshot). First you stage the files with git add, then you create the snapshot with git commit -m \"Your message\". You can create or edit files right here: use **echo \"text\" > filename** or **edit filename** (then save in the editor that appears). Then run git add and git commit in the terminal.",
        "whyImportant": "Commits are the building blocks of your history. Good commit messages help you and others understand the project later—especially important in DH when you need to cite or explain a specific version.",
        "whatToDo": [
          "In the terminal: create or edit a file (e.g. **echo \"Hello\" > readme.txt** or **edit readme.txt** and save)",
          "Then type: **git add .** (or **git add readme.txt**)",
          "Then: **git commit -m \"First commit\"** (use any short message)",
          "The lesson completes when you make a commit"
        ],
        "codeTemplate": "git add .\ngit commit -m \"Your short message\""
      },
      "git-4": {
        "title": "Checking status: git status",
        "description": "At any time you can run git status to see which files are modified, which are staged for the next commit, and which are untracked. This helps you stay in control before committing. Try editing a file (echo or edit) and run git status again to see the change.",
        "whyImportant": "Using git status regularly avoids committing the wrong files or forgetting to add something. It's a habit that will save you in real projects.",
        "whatToDo": [
          "In the terminal, type: **git status**",
          "Optionally change a file (**echo \"more\" >> readme.txt** or **edit readme.txt**) and run **git status** again",
          "Type **next** when done"
        ],
        "codeTemplate": "git status"
      },
      "branch-1": {
        "title": "Branching: create and switch branches",
        "description": "Branches let you work on a separate line of development without affecting the main branch. Use **git branch** to list branches (the current one has a *). Create a new branch with **git checkout -b <name>** (this creates and switches to it). Use **git checkout <name>** to switch to an existing branch—your working directory updates to match that branch's files.",
        "whyImportant": "Branching is essential for trying out changes, working on features separately, and collaborating. In DH projects you might use a branch for a new edition variant or a dataset update.",
        "whatToDo": [
          "Run **git branch** to see the current branch (main)",
          "Create a new branch: **git checkout -b feature** (or any name)",
          "Run **git branch** again to see both branches; you're now on the new one",
          "Optionally run **git checkout main** to switch back—notice how the terminal reflects the branch",
          "Type **next** when done"
        ],
        "codeTemplate": "git checkout -b feature"
      },
      "branch-2": {
        "title": "Merging branches",
        "description": "When you're happy with work on a branch, you merge it into another (usually main) with **git merge <branch>**. Git combines the histories. If the other branch has new commits since you branched, you may get a merge commit; if not, Git does a \"fast-forward\" (no merge commit). After merging, the current branch includes the other branch's commits.",
        "whyImportant": "Merging is how you bring feature work back into the main line. Understanding merge vs. fast-forward helps you keep history clear.",
        "whatToDo": [
          "Create a branch and make a commit on it (e.g. **git checkout -b feature**, edit a file, **git add .**, **git commit -m \"Add feature\"**)",
          "Switch to main: **git checkout main**",
          "Merge the branch: **git merge feature**",
          "Run **git log** to see the merged history. Type **next** when done"
        ],
        "codeTemplate": "git checkout -b feature\ngit add .\ngit commit -m \"Add feature\"\ngit checkout main\ngit merge feature"
      },
      "branch-3": {
        "title": "Squash merging",
        "description": "A **squash merge** (**git merge --squash <branch>**) brings the other branch's changes into your working tree as a single set of staged changes, without creating a merge commit. You then commit once—so multiple commits on the other branch become one commit on the current branch. Useful for keeping history tidy.",
        "whyImportant": "Squashing turns a messy series of \"WIP\" or \"fix typo\" commits into one clear commit, which is easier to review and cite.",
        "whatToDo": [
          "Create a branch and make one or more commits on it",
          "Switch to main: **git checkout main**",
          "Run **git merge --squash feature** (use your branch name)",
          "Run **git status**—you'll see the changes staged. Then **git commit -m \"Add feature (squashed)\"** to complete",
          "Type **next** when done"
        ],
        "codeTemplate": "git merge --squash feature\ngit commit -m \"Squashed feature\""
      },
      "branch-4": {
        "title": "Rebasing",
        "description": "**git rebase <branch>** moves your current branch's commits so they sit on top of the other branch. The result is a linear history: first the other branch's commits, then yours replayed. Use it to update a feature branch with the latest main, or to clean up history before merging.",
        "whyImportant": "Rebasing keeps history linear and avoids unnecessary merge commits. In DH projects it can make the evolution of a text or dataset easier to follow.",
        "whatToDo": [
          "Start from main with at least one commit. Create a branch and commit on it",
          "On the feature branch, run **git rebase main** (or rebase onto the branch you want to base on)",
          "Your branch's commits are now replayed on top of main. Use **git log** to see the linear history",
          "Type **next** when done"
        ],
        "codeTemplate": "git checkout -b feature\ngit commit -m \"Change\"\ngit rebase main"
      },
      "gh-1": {
        "title": "What is GitHub?",
        "description": "GitHub is a website that hosts Git repositories in the cloud. It gives you a backup of your repo, a visible history online, and tools for collaboration: others can clone your repo, suggest changes (pull requests), and you can manage issues and documentation. GitHub is very common in open source and in DH.",
        "whyImportant": "Git is local; GitHub is remote. Together they let you back up your work, share it, and collaborate. Many DH projects publish their data and code on GitHub for transparency and reuse.",
        "whatToDo": [
          "Read the section above. (You can sign up at https://github.com on your own computer later.)",
          "In the terminal, type **next** when ready to continue"
        ]
      },
      "gh-2": {
        "title": "Creating a repository on GitHub",
        "description": "On GitHub, you'd click \"New repository\", choose a name (e.g. my-dh-project), and get a URL to connect your local repo. In a real workflow you create this repo first, then use its URL in git remote and git push. You can try this on github.com later; for this lesson we focus on the idea.",
        "whyImportant": "The remote repo on GitHub is the place your local history will be copied to when you push. Creating it first gives you the URL you need for the next step.",
        "whatToDo": [
          "Read the steps above (you can create a real repo on GitHub later from your computer)",
          "In the terminal, type **next** when done"
        ]
      },
      "gh-3": {
        "title": "Pushing your code: git remote and git push",
        "description": "To send your local commits to GitHub, you link your repo to the remote with git remote add origin <URL>, then push with git push -u origin main. Here you can run these commands in the terminal (use any URL for the simulation); the lesson completes when you run git remote add or git push.",
        "whyImportant": "Pushing is how you back up and share your work. Once set up, it becomes a simple step in your workflow.",
        "whatToDo": [
          "In the terminal: **git remote add origin https://github.com/you/repo.git** (any URL is fine for this simulation)",
          "Then: **git push -u origin main**",
          "The lesson completes when you run the commands"
        ],
        "codeTemplate": "git remote add origin https://github.com/USER/REPO.git\ngit push -u origin main"
      },
      "gh-4": {
        "title": "Getting a copy: git clone and git pull",
        "description": "To get a full copy of someone else's repo (or your own from another computer), you'd use git clone <URL>. To update an existing copy, you run git pull. Here you can try these commands in the terminal—e.g. **git clone https://github.com/some/repo** or **git pull**—to see the simulated output.",
        "whyImportant": "Clone and pull are how you work with existing DH projects, contribute to others' work, or sync between machines. They're essential for collaboration.",
        "whatToDo": [
          "In the terminal, try **git clone https://github.com/some/repo** or **git pull**",
          "Type **next** when done"
        ],
        "codeTemplate": "git clone https://github.com/USER/REPO.git\ngit pull"
      },
      "collab-1": {
        "title": "Collaboration and good practices for DH",
        "description": "In practice, DH teams use branches (separate lines of work) and pull requests (proposed changes for review) on GitHub. Commit often with clear messages; push regularly so work is backed up. Use a README to explain the project and, if relevant, a license so others know how they can reuse your data and code. These practices make your project understandable and citable.",
        "whyImportant": "Good version control habits make DH projects reproducible, transparent, and easier to hand off or publish. They align with open scholarship and funder expectations.",
        "whatToDo": [
          "Read the collaboration and good-practice tips above",
          "In the terminal, type **next** to finish the course and view your certificate"
        ]
      }
    },
    "glossary": {
      "version control": "A system that records changes to files over time so you can recall or compare specific versions later.",
      "repository": "A folder managed by Git, containing the project files and the full history of commits.",
      "commit": "A snapshot of your project at a point in time, with a message and a unique ID. Commits form the history of the project.",
      "stage": "To mark files as ready to be included in the next commit (using git add).",
      "push": "To send your local commits to a remote repository (e.g. on GitHub).",
      "pull": "To fetch and merge changes from a remote repository into your current branch.",
      "clone": "To download a copy of a repository (including its history) from a remote server.",
      "remote": "A version of the repository hosted elsewhere (e.g. on GitHub), often named origin.",
      "GitHub": "A web platform that hosts Git repositories and provides tools for collaboration, issues, and documentation.",
      "Digital Humanities": "Research and teaching that combine computational methods with humanities disciplines; often involves texts, datasets, and code that benefit from version control."
    }
  },
  "fr": {
    "ui": {
      "title": "Apprendre Git et GitHub",
      "subtitle": "Contrôle de version dès le début — Essentiel pour les humanités numériques",
      "welcome": "Bienvenue dans Git et GitHub !",
      "welcomeDescription": "Ce tutoriel interactif enseigne le contrôle de version depuis les bases. Aucune connaissance préalable de Git, GitHub ou du contrôle de version n'est requise. Vous verrez pourquoi ces outils sont importants—surtout pour les projets en humanités numériques—et comment les utiliser. Tout se fait dans le terminal et l'éditeur de fichiers sur cette page : pas besoin d'utiliser le terminal de votre ordinateur ni d'installer Git.",
      "tutorialCredit": "Ce tutoriel reprend le même système de modules que le cours HTML/CSS. Il est disponible en anglais et en français.",
      "enterName": "Entrez votre nom",
      "chooseAvatar": "Choisissez votre avatar",
      "chooseAvatarOption": "Option d'avatar {number} sur {total}",
      "avatarPickerScrollHint": "Faites défiler pour plus d'avatars",
      "changeAvatar": "Changer d'avatar",
      "startLearning": "Commencer",
      "nameCertificateNote": "Ce nom apparaîtra sur votre certificat partageable à la fin de toutes les leçons.",
      "welcomeUser": "Bienvenue, {name} ! • Leçon {current} sur {total}",
      "courseProgress": "Progression — Cliquez sur une section pour y aller",
      "whatWeLearning": "Ce que nous apprenons :",
      "whyImportant": "Pourquoi c'est important :",
      "needHint": "Besoin d'un indice ? Cliquez pour voir quoi faire",
      "hideHint": "Masquer l'indice",
      "showHint": "Afficher l'indice",
      "whatToDo": "À faire :",
      "commandsToTry": "Commande(s) à essayer",
      "copyCommand": "Copier la commande",
      "terminalHint": "Utilisez le terminal à droite pour exécuter la commande.",
      "terminalNavHint": "Commandes : ls, pwd, cd, cat, echo, edit | git ... | next | back | clear",
      "editorLabel": "Éditeur de fichier",
      "save": "Enregistrer",
      "cancel": "Annuler",
      "back": "← Retour",
      "verifyCode": "C'est fait →",
      "skip": "Passer →",
      "tryAgain": "Réessayer",
      "nextLesson": "Leçon suivante →",
      "learnMore": "En savoir plus",
      "tip": "Conseil :",
      "copyUrl": "Copiez cette URL pour sauvegarder votre progression et reprendre plus tard :",
      "noFilesSaved": "Aucune donnée n'est enregistrée sur notre serveur—c'est le seul moyen de retrouver votre progression.",
      "certificateTitle": "Certificat de réussite",
      "certificateSubtitle": "Git et GitHub pour le contrôle de version",
      "certificateDescription": "Ceci certifie que",
      "certificateCompleted": "a suivi avec succès le tutoriel sur le contrôle de version, les bases de Git et GitHub—en mettant l'accent sur leur importance pour les humanités numériques.",
      "certificateCovered": "Ce cours a couvert :",
      "completedOn": "Terminé le",
      "congratulations": "Félicitations",
      "certificateShare": "Partagez ce certificat en copiant l'URL :",
      "certificateShareDescription": "Vous pouvez copier l'URL ci-dessus pour partager votre certificat.",
      "emailCertificate": "Envoyer le certificat par courriel",
      "emailCertificateSubject": "Mon certificat Git et GitHub",
      "emailCertificateBody": "J'ai terminé le tutoriel Git et GitHub ! Voici mon certificat :",
      "certificateItem1": "Qu'est-ce que le contrôle de version et pourquoi il compte pour les humanités numériques",
      "certificateItem2": "Bases de Git : dépôts, commits et historique",
      "certificateItemBranching": "Branches : créer, fusionner, squash et rebase",
      "certificateItem3": "GitHub : hébergement, push, pull et clone",
      "certificateItem4": "Collaboration et bonnes pratiques pour les projets en HN",
      "successMessage": "Très bien ! Passez à la leçon suivante quand vous êtes prêt.",
      "errorMessage": "Pas tout à fait. Assurez-vous de : {elements}",
      "selectLanguage": "Choisir la langue",
      "studentNameAria": "Nom de l'étudiant : {name}",
      "completed": "Terminé",
      "jumpToSection": "Aller à la section {section}. {completed} sur {total} leçons terminées.",
      "hintRegion": "Instructions de l'indice",
      "glossaryButton": "Glossaire",
      "glossaryTitle": "Glossaire",
      "glossarySearchPlaceholder": "Rechercher un terme...",
      "glossaryClose": "Fermer le glossaire",
      "glossaryNoResults": "Aucun terme ne correspond.",
      "skipToMainContent": "Aller au contenu principal",
      "definitionOf": "Définition de {term}",
      "backToLessons": "Retour aux leçons",
      "viewCertificate": "Voir le certificat",
      "reportBug": "Signaler un bug"
    },
    "categories": {
      "versionControl": "Contrôle de version",
      "gitBasics": "Bases de Git",
      "branching": "Branches",
      "github": "GitHub",
      "collaboration": "Collaboration"
    },
    "lessons": {
      "vc-1": {
        "title": "Qu'est-ce que le contrôle de version ?",
        "description": "Le contrôle de version permet de sauvegarder et de suivre l'évolution de vos fichiers dans le temps. Au lieu d'accumuler des fichiers comme \"these_v1.docx\", \"these_finale.docx\" et \"these_VRAIMENT_finale.docx\", vous gardez un seul projet et un historique de chaque modification : qui a changé quoi, et quand. Vous pouvez revenir à n'importe quelle version antérieure si besoin.",
        "whyImportant": "Sans contrôle de version, il est facile de perdre du travail, d'écraser les changements d'un collègue ou d'oublier ce qu'on a modifié. Avec lui, vous avez un historique clair et pouvez collaborer en toute sécurité. Pour les projets en humanités numériques—éditions, corpus, jeux de données, sites web—c'est essentiel : on travaille souvent en équipe, on itère sur des années, et on doit pouvoir citer ou reproduire un état précis du projet.",
        "whatToDo": [
          "Lire l'explication ci-dessus",
          "Penser à un projet (ex. une édition de texte ou un jeu de données) où vous voudriez suivre chaque changement",
          "Dans le terminal à droite, taper **next** quand vous êtes prêt à continuer"
        ]
      },
      "vc-2": {
        "title": "Pourquoi le contrôle de version compte pour les humanités numériques",
        "description": "Les projets en humanités numériques mêlent souvent textes, métadonnées, code et plusieurs personnes. Le contrôle de version permet : d'avoir une seule source de vérité au lieu de copies éparpillées ; de voir qui a ajouté ou modifié quelle ligne ; de revenir en arrière en cas d'erreur ; et de permettre à d'autres (ou à vous plus tard) de comprendre et reproduire votre travail. Beaucoup de financeurs et d'éditeurs attendent ou recommandent désormais le contrôle de version pour la transparence et la reproductibilité.",
        "whyImportant": "Le travail en HN est de la recherche. Pouvoir montrer comment un corpus ou une édition a évolué, et restaurer ou citer une version donnée, sert à la fois la pratique savante et la science ouverte. Apprendre Git et GitHub est l'une des compétences les plus utiles à ajouter à votre boîte à outils HN.",
        "whatToDo": [
          "Lire pourquoi les projets HN bénéficient du contrôle de version",
          "Dans le terminal, taper **next** pour continuer"
        ]
      },
      "git-1": {
        "title": "Qu'est-ce que Git ?",
        "description": "Git est un outil gratuit et open source qui fait du contrôle de version sur votre ordinateur. Créé pour gérer le code source du noyau Linux, il est utilisé partout dans le monde. Git fonctionne en local : il conserve tout l'historique de votre projet dans un dossier caché (un dépôt) à l'intérieur du projet. Vous n'avez pas besoin d'internet pour faire des commits—seulement quand vous voulez partager ou sauvegarder sur un serveur comme GitHub. Dans ce cours nous simulons Git dans le terminal sur cette page—aucune installation requise.",
        "whyImportant": "Git est le standard du contrôle de version en logiciel et dans beaucoup de projets HN. Comprendre qu'il est « local d'abord » (votre historique est sur votre machine) aide à voir pourquoi on ajoute ensuite GitHub pour la sauvegarde et la collaboration.",
        "whatToDo": [
          "Dans le terminal à droite, taper : **git --version**",
          "Vous verrez une version simulée. (Sur un vrai ordinateur vous l'installeriez depuis https://git-scm.com/.)",
          "Taper **next** quand vous êtes prêt à continuer"
        ],
        "codeTemplate": "git --version"
      },
      "git-2": {
        "title": "Votre premier dépôt : git init",
        "description": "Un dépôt (repository) est le dossier où Git conserve l'historique du projet. Pour transformer un dossier en dépôt Git, on lance git init dans ce dossier. Ici, le terminal est déjà dans un dossier projet simulé (~/my-project). Après git init, Git suivra les changements des fichiers quand vous le lui demanderez.",
        "whyImportant": "Créer un dépôt est la première étape pour utiliser Git. Ensuite nous ajouterons des fichiers et ferons des commits dans ce dépôt—tout dans le terminal du navigateur.",
        "whatToDo": [
          "Dans le terminal, taper : **git init**",
          "Vous devriez voir « Initialized empty Git repository in .git/ »",
          "La leçon se valide automatiquement quand vous exécutez la commande"
        ],
        "codeTemplate": "git init"
      },
      "git-3": {
        "title": "Mise en stage et commit : git add et git commit",
        "description": "Git ne sauvegarde pas chaque changement automatiquement. Vous choisissez quels changements inclure dans un « commit » (une photo du projet). D'abord vous mettez les fichiers en stage avec git add, puis vous créez la photo avec git commit -m \"Votre message\". Vous pouvez créer ou modifier des fichiers ici : utilisez **echo \"texte\" > nomfichier** ou **edit nomfichier** (puis enregistrez dans l'éditeur). Puis lancez git add et git commit dans le terminal.",
        "whyImportant": "Les commits sont les briques de votre historique. De bons messages de commit aident vous et les autres à comprendre le projet plus tard—surtout en HN quand il faut citer ou expliquer une version précise.",
        "whatToDo": [
          "Dans le terminal : créer ou modifier un fichier (ex. **echo \"Bonjour\" > readme.txt** ou **edit readme.txt** puis enregistrer)",
          "Puis taper : **git add .** (ou **git add readme.txt**)",
          "Puis : **git commit -m \"Premier commit\"** (un message court)",
          "La leçon se valide quand vous faites un commit"
        ],
        "codeTemplate": "git add .\ngit commit -m \"Votre message court\""
      },
      "git-4": {
        "title": "Vérifier l'état : git status",
        "description": "À tout moment vous pouvez lancer git status pour voir quels fichiers sont modifiés, lesquels sont en stage pour le prochain commit, et lesquels ne sont pas suivis. Essayez de modifier un fichier (echo ou edit) et relancez git status pour voir le changement.",
        "whyImportant": "Utiliser git status régulièrement évite de committer les mauvais fichiers ou d'oublier d'ajouter quelque chose. C'est une habitude qui vous servira dans les vrais projets.",
        "whatToDo": [
          "Dans le terminal, taper : **git status**",
          "Optionnel : modifier un fichier (**echo \"suite\" >> readme.txt** ou **edit readme.txt**) puis **git status**",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git status"
      },
      "branch-1": {
        "title": "Branches : créer et changer de branche",
        "description": "Les branches permettent de travailler sur une ligne de développement séparée sans toucher à la branche principale. Utilisez **git branch** pour lister les branches (la courante a un *). Créez une branche avec **git checkout -b <nom>** (création et bascule). Utilisez **git checkout <nom>** pour passer à une branche existante—le répertoire de travail est mis à jour pour refléter les fichiers de cette branche.",
        "whyImportant": "Les branches sont essentielles pour tester des changements, travailler sur des fonctionnalités à part et collaborer. En HN vous pouvez avoir une branche pour une variante d'édition ou une mise à jour de jeu de données.",
        "whatToDo": [
          "Lancer **git branch** pour voir la branche courante (main)",
          "Créer une branche : **git checkout -b feature** (ou un autre nom)",
          "Relancer **git branch** pour voir les deux branches ; vous êtes sur la nouvelle",
          "Optionnel : **git checkout main** pour revenir—observez que le terminal reflète la branche",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout -b feature"
      },
      "branch-2": {
        "title": "Fusionner des branches",
        "description": "Quand le travail sur une branche vous convient, vous la fusionnez dans une autre (souvent main) avec **git merge <branche>**. Git combine les historiques. Si l'autre branche a de nouveaux commits depuis la divergence, vous pouvez avoir un commit de merge ; sinon, Git fait un « fast-forward » (pas de commit de merge). Après la fusion, la branche courante contient les commits de l'autre.",
        "whyImportant": "La fusion permet de réintégrer le travail d'une branche dans la ligne principale. Comprendre merge vs. fast-forward aide à garder un historique clair.",
        "whatToDo": [
          "Créer une branche et faire un commit (ex. **git checkout -b feature**, modifier un fichier, **git add .**, **git commit -m \"Ajout feature\"**)",
          "Revenir sur main : **git checkout main**",
          "Fusionner : **git merge feature**",
          "Lancer **git log** pour voir l'historique fusionné. Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout -b feature\ngit add .\ngit commit -m \"Ajout feature\"\ngit checkout main\ngit merge feature"
      },
      "branch-3": {
        "title": "Fusion squash",
        "description": "Une **fusion squash** (**git merge --squash <branche>**) apporte les changements de l'autre branche dans votre arbre de travail comme un seul ensemble de changements en stage, sans créer de commit de merge. Vous commitez ensuite une fois—plusieurs commits sur l'autre branche deviennent un seul commit sur la branche courante. Utile pour garder un historique propre.",
        "whyImportant": "Squasher transforme une série de commits « WIP » ou « typo » en un commit clair, plus facile à relire et citer.",
        "whatToDo": [
          "Créer une branche et y faire un ou plusieurs commits",
          "Revenir sur main : **git checkout main**",
          "Lancer **git merge --squash feature** (avec le nom de votre branche)",
          "Lancer **git status**—vous verrez les changements en stage. Puis **git commit -m \"Feature squashed\"** pour terminer",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git merge --squash feature\ngit commit -m \"Feature squashed\""
      },
      "branch-4": {
        "title": "Rebase",
        "description": "**git rebase <branche>** déplace les commits de la branche courante pour qu'ils reposent sur l'autre branche. Le résultat est un historique linéaire : d'abord les commits de l'autre branche, puis les vôtres rejoués. Utilisez-le pour mettre à jour une branche feature avec le dernier main, ou pour nettoyer l'historique avant une fusion.",
        "whyImportant": "Le rebase garde un historique linéaire et évite les commits de merge inutiles. En HN cela peut rendre l'évolution d'un texte ou d'un jeu de données plus lisible.",
        "whatToDo": [
          "Partir de main avec au moins un commit. Créer une branche et committer dessus",
          "Sur la branche feature, lancer **git rebase main**",
          "Les commits de votre branche sont rejoués sur main. Utilisez **git log** pour voir l'historique linéaire",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout -b feature\ngit commit -m \"Changement\"\ngit rebase main"
      },
      "gh-1": {
        "title": "Qu'est-ce que GitHub ?",
        "description": "GitHub est un site qui héberge des dépôts Git dans le cloud. Il vous donne une sauvegarde de votre dépôt, un historique visible en ligne, et des outils pour collaborer : d'autres peuvent cloner votre dépôt, proposer des changements (pull requests), et vous pouvez gérer les issues et la documentation. GitHub est très répandu dans l'open source et en HN.",
        "whyImportant": "Git est local ; GitHub est distant. Ensemble ils permettent de sauvegarder votre travail, de le partager et de collaborer. Beaucoup de projets HN publient leurs données et leur code sur GitHub pour la transparence et la réutilisation.",
        "whatToDo": [
          "Lire la section ci-dessus. (Vous pourrez créer un compte sur https://github.com plus tard depuis votre ordinateur.)",
          "Dans le terminal, taper **next** quand vous êtes prêt à continuer"
        ]
      },
      "gh-2": {
        "title": "Créer un dépôt sur GitHub",
        "description": "Sur GitHub, vous cliqueriez sur « New repository », choisiriez un nom (ex. mon-projet-hn) et obtiendriez une URL pour connecter votre dépôt local. Dans un vrai workflow on crée ce dépôt d'abord, puis on utilise son URL dans git remote et git push. Vous pourrez essayer sur github.com plus tard ; pour cette leçon on se concentre sur l'idée.",
        "whyImportant": "Le dépôt distant sur GitHub est l'endroit où votre historique local sera copié quand vous ferez un push. Le créer d'abord vous donne l'URL nécessaire pour l'étape suivante.",
        "whatToDo": [
          "Lire les étapes ci-dessus (vous pourrez créer un vrai dépôt sur GitHub plus tard depuis votre ordinateur)",
          "Dans le terminal, taper **next** quand c'est fait"
        ]
      },
      "gh-3": {
        "title": "Pousser votre code : git remote et git push",
        "description": "Pour envoyer vos commits locaux sur GitHub, vous liez votre dépôt au distant avec git remote add origin <URL>, puis vous poussez avec git push -u origin main. Ici vous pouvez exécuter ces commandes dans le terminal (une URL quelconque suffit pour la simulation) ; la leçon se valide quand vous exécutez git remote add ou git push.",
        "whyImportant": "Pousser (push) est la façon de sauvegarder et partager votre travail. Une fois configuré, ça devient une étape simple de votre routine.",
        "whatToDo": [
          "Dans le terminal : **git remote add origin https://github.com/you/repo.git** (n'importe quelle URL pour cette simulation)",
          "Puis : **git push -u origin main**",
          "La leçon se valide quand vous exécutez les commandes"
        ],
        "codeTemplate": "git remote add origin https://github.com/USER/REPO.git\ngit push -u origin main"
      },
      "gh-4": {
        "title": "Obtenir une copie : git clone et git pull",
        "description": "Pour obtenir une copie complète du dépôt de quelqu'un (ou du vôtre depuis un autre ordinateur), on utilise git clone <URL>. Pour mettre à jour une copie existante, on lance git pull. Ici vous pouvez essayer ces commandes dans le terminal—ex. **git clone https://github.com/some/repo** ou **git pull**—pour voir la sortie simulée.",
        "whyImportant": "Clone et pull sont la façon de travailler avec des projets HN existants, de contribuer au travail d'autres, ou de synchroniser entre machines. Ils sont essentiels pour la collaboration.",
        "whatToDo": [
          "Dans le terminal, essayer **git clone https://github.com/some/repo** ou **git pull**",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git clone https://github.com/USER/REPO.git\ngit pull"
      },
      "collab-1": {
        "title": "Collaboration et bonnes pratiques pour la HN",
        "description": "En pratique, les équipes HN utilisent des branches (lignes de travail séparées) et des pull requests (changements proposés pour revue) sur GitHub. Committez souvent avec des messages clairs ; poussez régulièrement pour sauvegarder. Utilisez un README pour expliquer le projet et, si pertinent, une licence pour que les autres sachent comment réutiliser vos données et votre code. Ces pratiques rendent votre projet compréhensible et citable.",
        "whyImportant": "De bonnes habitudes de contrôle de version rendent les projets HN reproductibles, transparents et plus faciles à transmettre ou publier. Elles s'alignent avec la science ouverte et les attentes des financeurs.",
        "whatToDo": [
          "Lire les conseils de collaboration et de bonnes pratiques ci-dessus",
          "Dans le terminal, taper **next** pour terminer le cours et voir votre certificat"
        ]
      }
    },
    "glossary": {
      "version control": "Système qui enregistre les changements des fichiers dans le temps pour pouvoir retrouver ou comparer des versions précises.",
      "repository": "Dossier géré par Git, contenant les fichiers du projet et tout l'historique des commits.",
      "commit": "Photo du projet à un instant donné, avec un message et un identifiant unique. Les commits forment l'historique du projet.",
      "stage": "Marquer des fichiers comme prêts à être inclus dans le prochain commit (avec git add).",
      "push": "Envoyer vos commits locaux vers un dépôt distant (ex. sur GitHub).",
      "pull": "Récupérer et fusionner les changements d'un dépôt distant dans votre branche actuelle.",
      "clone": "Télécharger une copie d'un dépôt (avec son historique) depuis un serveur distant.",
      "remote": "Version du dépôt hébergée ailleurs (ex. sur GitHub), souvent nommée origin.",
      "GitHub": "Plateforme web qui héberge des dépôts Git et propose des outils de collaboration, issues et documentation.",
      "Digital Humanities": "Recherche et enseignement qui combinent méthodes numériques et disciplines des humanités ; implique souvent textes, jeux de données et code qui bénéficient du contrôle de version."
    }
  }
}
