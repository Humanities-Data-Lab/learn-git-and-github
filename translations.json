{
  "en": {
    "ui": {
      "title": "Learn Git and GitHub",
      "subtitle": "Version control from zero — Essential for Digital Humanities",
      "welcome": "Welcome to Git and GitHub!",
      "welcomeDescription": "This interactive tutorial teaches version control from the ground up. No prior knowledge of Git, GitHub, or version control is assumed. You'll learn why these tools matter—especially for Digital Humanities projects—and how to use them. Everything is done in the terminal and file editor on this page: you do not need to use your computer's terminal or install Git.",
      "tutorialCredit": "Made by Asher Lacho in coordination with the Humanities Data Lab. This tutorial follows the same module system as the HTML/CSS course. It is available in English and French.",
      "enterName": "Enter your name",
      "chooseAvatar": "Choose your avatar",
      "chooseAvatarOption": "Avatar option {number} of {total}",
      "avatarPickerScrollHint": "Scroll for more avatars",
      "changeAvatar": "Change avatar",
      "createYourAvatar": "Create your avatar",
      "avatarSkinTone": "Skin tone",
      "avatarHairStyle": "Hair style",
      "avatarHairColor": "Hair color",
      "avatarClothingStyle": "Clothing style",
      "avatarClothingColor": "Clothing color",
      "avatarMouth": "Mouth",
      "avatarEyes": "Eyes",
      "avatarAccessories": "Glasses & accessibility",
      "avatarAccessoriesColor": "Glasses / accessory color",
      "avatarEyebrows": "Eyebrows",
      "avatarFacialHair": "Facial hair",
      "avatarFacialHairColor": "Facial hair color",
      "avatarHatColor": "Hat / headwear color",
      "avatarClothingGraphic": "Shirt graphic",
      "addColor": "Add color",
      "addColorHint": "Click a swatch to change the colour; add more to give the avatar alternate shades.",
      "removeColor": "Remove",
      "done": "Done",
      "randomizeAvatar": "Randomize avatar",
      "startLearning": "Start Learning",
      "nameCertificateNote": "This name will appear on your shareable certificate when you complete all lessons.",
      "welcomeUser": "Welcome, {name}! • Lesson {current} of {total}",
      "courseProgress": "Course Progress - Click any section to jump to it",
      "whatWeLearning": "What we're learning:",
      "whyImportant": "Why it's important:",
      "needHint": "Need a hint? Click to see what to do",
      "hideHint": "Hide hint",
      "showHint": "Show hint",
      "whatToDo": "What to do:",
      "commandsToTry": "Command(s) to try",
      "copyCommand": "Copy command",
      "terminalHint": "Use the terminal on the right to run the command.",
      "terminalNavHint": "Commands: ls, pwd, cd, cat, echo, edit | git ... | next | back | clear",
      "editorLabel": "File editor",
      "save": "Save",
      "cancel": "Cancel",
      "back": "← Back",
      "verifyCode": "I've done this →",
      "skip": "Skip →",
      "tryAgain": "Try Again",
      "nextLesson": "Next Lesson →",
      "learnMore": "Learn more",
      "tip": "Tip:",
      "copyUrl": "Copy this URL to save your progress and resume later:",
      "copyToClipboard": "Copy to clipboard",
      "copied": "Copied!",
      "noFilesSaved": "No data is saved on our server—this is the only way to re-access your progress.",
      "certificateTitle": "Certificate of Completion",
      "certificateSubtitle": "Git and GitHub for Version Control",
      "certificateDescription": "This certifies that",
      "certificateCompleted": "has successfully completed the interactive tutorial on version control, Git basics, and GitHub—with a focus on why these tools matter for Digital Humanities.",
      "certificateCovered": "This course covered:",
      "completedOn": "Completed on",
      "congratulations": "Congratulations",
      "certificateShare": "Share this certificate with anyone by copying the URL:",
      "certificateShareDescription": "You can copy the URL above to share your certificate.",
      "printCertificate": "Print Certificate",
      "emailCertificate": "Email Certificate",
      "emailCertificateSubject": "Check out my certificate",
      "emailCertificateBody": "I've completed the Git and GitHub tutorial! Check out my certificate:",
      "certificateItem1": "What is version control and why it matters for Digital Humanities",
      "certificateItem2": "Git basics: repositories, commits, and history",
      "certificateItemBranching": "Branching: create branches, merge, squash, and rebase",
      "certificateItem3": "GitHub: hosting, push, pull, and clone",
      "certificateItem4": "Collaboration and good practices for DH projects",
      "successMessage": "Well done! Continue to the next lesson when ready.",
      "errorMessage": "Not quite right. Make sure you: {elements}",
      "selectLanguage": "Select language",
      "studentNameAria": "Student name: {name}",
      "completed": "Completed",
      "jumpToSection": "Jump to {section} section. {completed} of {total} lessons completed.",
      "hintRegion": "Hint instructions",
      "glossaryButton": "Glossary",
      "glossaryTitle": "Glossary",
      "glossarySearchPlaceholder": "Search terms...",
      "glossaryClose": "Close glossary",
      "glossaryNoResults": "No terms match your search.",
      "cheatsheetButton": "Cheatsheet",
      "cheatsheetTitle": "Git & GitHub Cheatsheet",
      "cheatsheetPrint": "Print",
      "cheatsheetClose": "Close",
      "skipToMainContent": "Skip to main content",
      "definitionOf": "Definition of {term}",
      "backToLessons": "Back to lessons",
      "viewCertificate": "View certificate",
      "reportBug": "Report bug",
      "branchVisualizerHelpButton": "Help",
      "branchVisualizerHelpTitle": "About the branch graph",
      "branchVisualizerHelpBody": "This graph shows your Git branches and commits. Each dot is a commit (with its short hash and message). Branches appear as separate lines; the main branch and any branch you create (e.g. with git checkout -b) are shown. The label \"current\" shows which branch you're on. New branches appear as soon as you create them, even before you make a commit on them.",
      "lessonCompleteNext": "Lesson complete! Moving to next lesson...",
      "lessonCompleteTypeNext": "Lesson complete! Type \"next\" or click the button to continue.",
      "goingBackToLesson": "Going back to previous lesson.",
      "editUsage": "edit: usage: edit <filename>",
      "editingFile": "Editing {filename} (save or cancel in editor below)",
      "editFileReminder": "To edit a file here: type **edit** followed by the filename in the terminal (e.g. **edit readme.txt**); the editor opens below—make your changes and click Save.",
      "unsupportedGitCommand": "The command you entered may be valid in Git, but this tutorial's simulated environment doesn't support it—we only cover a subset of commands here."
    },
    "categories": {
      "tutorialIntro": "How this tutorial works",
      "versionControl": "Version Control",
      "gitBasics": "Git Basics",
      "branching": "Branching",
      "github": "GitHub",
      "collaboration": "Collaboration"
    },
    "lessons": {
      "intro-1": {
        "title": "The terminal: what works like the real thing",
        "description": "This tutorial has a **simulated terminal** on the right. Much of it behaves like a real terminal (e.g. on your Mac, Linux, or in VS Code). You type commands and see output; the prompt shows your current folder (**~/my-project**). Standard shell commands work as you’d expect: **ls** lists files, **pwd** shows the current directory, **cd** changes directory, **cat** shows file contents, and **echo** can create or append to files (e.g. **echo \"Hello\" > readme.txt**). So the way you navigate and run commands is very close to a real terminal.",
        "whyImportant": "Getting used to typing commands here will make the move to a real terminal or IDE much easier. The habits you build (reading the prompt, using ls and cat to see what’s there) transfer directly.",
        "whatToDo": [
          "Read the explanation above",
          "In the terminal, try **ls** or **pwd** to see they work like a normal shell",
          "Type **next** when you’re ready to continue"
        ]
      },
      "intro-2": {
        "title": "What we’ve simplified: edit command and Git simulation",
        "description": "A few things in this tutorial are **simplified or custom** so you can learn without installing anything. **Editing files:** In a real terminal you’d open a text editor (e.g. **nano**, **vim**, or open the file in an app). Here we use a built-in **edit** command: type **edit filename** (e.g. **edit readme.txt**) in the terminal and an **editor panel opens below**—change the content and click **Save**. That’s only for this tutorial. **Git:** We simulate Git in the browser. Commands like **git init**, **git add**, **git commit**, **git status**, **git branch**, **git merge**, **git remote**, **git push**, and **git pull** behave like real Git and teach the real workflow. But there is no real network: **git push** and **git pull** don’t talk to real servers—remotes and clones are simulated. You don't need to understand this right now—we'll cover remotes and clones in later lessons. So: terminal navigation and file commands are close to real; **edit** is tutorial-only; Git logic is real, but remotes are simulated.",
        "whyImportant": "Knowing what’s “real” vs “for this lesson” helps you know what to expect when you use Git and a terminal on your own machine. You’ll use a real editor and real GitHub; the concepts you learn here will still apply.",
        "whatToDo": [
          "Read the explanation above",
          "When a lesson asks you to edit a file, remember: type **edit** followed by the filename the lesson specifies (e.g. **edit readme.txt**) in the terminal, then use the editor below and click Save",
          "Type **next** when you’re ready to start the version control lessons"
        ]
      },
      "vc-1": {
        "title": "What is version control?",
        "description": "Version control is a way to save and track changes to your files over time. Instead of ending up with files like \"thesis_v1.docx\", \"thesis_final.docx\", and \"thesis_FINAL_really.docx\", you keep one project and a history of every change: who changed what, and when. You can go back to any earlier version if you need to.",
        "whyImportant": "Without version control, it's easy to lose work, overwrite someone else's changes, or forget what you changed. With it, you have a clear history and can collaborate safely. For Digital Humanities projects—editions, corpora, datasets, and websites—this is essential: you often work in teams, iterate over years, and need to cite or reproduce a specific state of the project.",
        "whatToDo": [
          "Read the explanation above",
          "Think of a project (e.g. a text edition or dataset) where you'd want to track every change",
          "In the terminal on the right, type **next** when you're ready to continue"
        ]
      },
      "vc-2": {
        "title": "Why version control matters for Digital Humanities",
        "description": "Digital Humanities projects usually involve texts, metadata, code, and often several people. Version control lets you: keep a single source of truth instead of scattered copies; see who added or changed which line; recover from mistakes; and give others (or future you) a way to understand and reproduce your work. Many funders and publishers now expect or recommend using version control for transparency and reproducibility.",
        "whyImportant": "DH work is research. Being able to show how a corpus or edition evolved, and to restore or cite a specific version, supports both scholarly practice and open science. Learning Git and GitHub is one of the most practical skills you can add to your DH toolkit.",
        "whatToDo": [
          "Read why DH projects benefit from version control",
          "In the terminal, type **next** to continue"
        ]
      },
      "git-1": {
        "title": "What is Git?",
        "description": "Git is a free, open-source tool that does version control on your computer. It was created to manage the Linux kernel source code and is now used worldwide. Git runs locally: it keeps the full history of your project in a hidden folder (a repository) inside your project. You don't need the internet to make commits—only when you want to share or back up with a server like GitHub. In this course we simulate Git in the terminal on this page—no installation needed.",
        "whyImportant": "Git is the standard for version control in software and in many DH projects. Understanding that Git is local-first (your history lives on your machine) helps you see why we later add GitHub for backup and collaboration.",
        "whatToDo": [
          "In the terminal on the right, type: **git --version**",
          "You'll see a simulated version. (On a real computer you'd install from https://git-scm.com/.)",
          "Type **next** when ready to continue"
        ],
        "codeTemplate": "git --version"
      },
      "git-2": {
        "title": "Your first repository: git init",
        "description": "A repository (or repo) is the folder where Git keeps the history of your project. To turn a folder into a Git repository, you run git init in that folder. Here, the terminal is already in a simulated project folder (~/my-project). After git init, Git will track changes to files when you tell it to.",
        "whyImportant": "Creating a repo is the first step to using Git. From here on, we'll add files and make commits inside this repo—all in the browser terminal.",
        "whatToDo": [
          "In the terminal, type: **git init**",
          "You should see \"Initialized empty Git repository in .git/\"",
          "The lesson completes automatically when you run the command"
        ],
        "codeTemplate": "git init"
      },
      "git-3": {
        "title": "Staging and committing: git add and git commit",
        "description": "Git doesn't save every change automatically. You choose which changes to include in a \"commit\" (a snapshot). First you stage the files with git add, then you create the snapshot with git commit -m \"Your message\". You can create or edit files right here: use **echo \"text\" > filename** or **edit filename**. To edit a file in this simulation: type **edit** followed by the filename in the terminal; the editor opens below—make your changes and click Save. Then run git add and git commit in the terminal.",
        "whyImportant": "Commits are the building blocks of your history. Good commit messages help you and others understand the project later—especially important in DH when you need to cite or explain a specific version.",
        "whatToDo": [
          "In the terminal: create or edit a file (e.g. **echo \"Hello\" > readme.txt** or **edit readme.txt** and save). To edit a file: type **edit filename** in the terminal; the editor opens below—click Save when done.",
          "Then type: **git add .** (or **git add readme.txt**)",
          "Then: **git commit -m \"First commit\"** (use any short message)",
          "The lesson completes when you make a commit"
        ],
        "codeTemplate": "git add .\ngit commit -m \"Your short message\""
      },
      "git-4": {
        "title": "Checking status: git status",
        "description": "At any time you can run git status to see which files are modified in your **working tree**, which are **staged changes** (ready for the next commit), and which are untracked. This helps you stay in control before committing. Try editing a file (echo or edit) and run git status again to see the change. To edit a file here: type **edit filename** in the terminal; the editor opens below—then click Save.",
        "whyImportant": "Using git status regularly avoids committing the wrong files or forgetting to add something. It's a habit that will save you in real projects.",
        "whatToDo": [
          "In the terminal, type: **git status**",
          "Optionally change a file (**echo \"more\" >> readme.txt** or **edit readme.txt**) and run **git status** again (to edit: type **edit readme.txt** in the terminal; the editor opens below—click Save)",
          "Type **next** when done"
        ],
        "codeTemplate": "git status"
      },
      "git-5": {
        "title": "Ignoring files: .gitignore",
        "description": "Some files should never be committed: secrets, build outputs, or local config. A **.gitignore** file is a series of patterns (one per line). Git matches each pattern against file names: if a file matches, Git ignores it—it won't appear as untracked in **git status** and won't be added with **git add .**. Patterns can be literal (e.g. **secret.txt** for that exact file) or use ** * ** as a wildcard meaning \"any characters\". For example, ***.log** means \"any file that ends in .log\", so **debug.log**, **server.log**, and **error.log** would all be ignored. Another practical pattern is ***.env** to ignore environment files that often contain secrets. Create **.gitignore** with **edit .gitignore**; add your patterns, then click Save. Create a file that matches one of your patterns (e.g. **echo \"x\" > secret.txt** or **echo \"x\" > debug.log**) and run **git status**—the matched file won't be listed. Commit the **.gitignore** file itself so the rules are shared with others. GitHub maintains a collection of commonly used .gitignore templates: [github/gitignore](https://github.com/github/gitignore).",
        "whyImportant": "Without .gitignore you might commit passwords, API keys, or thousands of generated files. In DH projects you often ignore data caches, local config, and editor backups.",
        "whatToDo": [
          "Create a **.gitignore** file (e.g. **edit .gitignore** and add a pattern: **secret.txt** for that exact file, or ***.log** to ignore any file ending in .log). Type **edit .gitignore** in the terminal; the editor opens below—add at least one pattern and click Save.",
          "Optionally create a file that matches (e.g. **echo \"don't commit\" > secret.txt**)",
          "Run **git status**—you should see **.gitignore** as untracked but not the ignored file",
          "Run **git add .gitignore** and **git commit -m \"Add .gitignore\"** to finish the lesson"
        ],
        "codeTemplate": "edit .gitignore\n# add line: secret.txt\ngit add .gitignore\ngit commit -m \"Add .gitignore\""
      },
      "git-6": {
        "title": "Fixing mistakes: unstage, discard, amend",
        "description": "You can fix common slip-ups without losing work. **git restore --staged <file>** unstage a file (remove it from the next commit). **git restore <file>** discards uncommitted changes in that file in your **working tree**—it reverts the file to the last committed version (use with care). **git commit --amend -m \"New message\"** replaces the last commit: either change the message or add more **staged changes** into that commit. Here you have one commit; try unstaging a file, discarding changes, or amending the last commit.",
        "whyImportant": "Everyone stages the wrong file or commits with a typo. Knowing how to unstage, discard, or amend keeps your history clean and avoids embarrassing pushes.",
        "whatToDo": [
          "**Unstage:** Change **readme.txt** (type **edit readme.txt** in the terminal; the editor opens below—edit and click Save), run **git add readme.txt**, then **git restore --staged readme.txt**. Run **git status** to see it's no longer staged.",
          "**Discard changes:** Change **readme.txt** again (**edit readme.txt** in the terminal, then Save), then **git restore readme.txt**. The file is back to the last committed version.",
          "**Amend:** Make a small change, **git add** and **git commit -m \"Typo\"**, then **git commit --amend -m \"Fixed typo\"** to replace the last commit message.",
          "Type **next** when you've tried at least one of these"
        ],
        "codeTemplate": "git add readme.txt\ngit restore --staged readme.txt\ngit status"
      },
      "branch-1": {
        "title": "Branching: create and switch branches",
        "description": "Branches let you work on a separate line of development without affecting the main branch. Each branch can have its own version of files. Use **git branch** to list branches (the current one has a *). Create a new branch with **git checkout -b <name>** (this creates and switches to it). Use **git checkout <name>** to switch to an existing branch—your working directory updates to match that branch's files. In this lesson you'll change **readme.txt** differently on each branch, then use **cat readme.txt** to see that the file content is different on each branch.",
        "whyImportant": "Branching is essential for trying out changes, working on features separately, and collaborating. In DH projects you might use a branch for a new edition variant or a dataset update.",
        "whatToDo": [
          "Run **git branch** to see the current branch (main)",
          "Create a new branch: **git checkout -b feature** (or any name)",
          "Change **readme.txt** on this branch (e.g. **echo \"Feature version\" > readme.txt** or **edit readme.txt**). To edit: type **edit readme.txt** in the terminal; the editor opens below—click Save. Then **git add readme.txt** and **git commit -m \"Feature content\"**",
          "Switch to main: **git checkout main**. Run **cat readme.txt** to see main's version of the file",
          "Change **readme.txt** on main to something different (e.g. **echo \"Main version\" > readme.txt** or **edit readme.txt**—type **edit readme.txt** in the terminal, edit in the panel below, then Save). Then **git add readme.txt** and **git commit -m \"Main content\"**",
          "Run **cat readme.txt** again—you'll see the main version. Then **git checkout feature** and run **cat readme.txt**—you'll see the feature version. Each branch has its own copy.",
          "Type **next** when done"
        ],
        "codeTemplate": "git checkout -b feature\necho \"Feature version\" > readme.txt\ngit add readme.txt\ngit commit -m \"Feature content\"\ngit checkout main\ncat readme.txt"
      },
      "branch-2": {
        "title": "Merging branches",
        "description": "When you're happy with work on a branch, you merge it into another (usually main) with **git merge <branch>**. Git combines the histories. If the other branch has new commits since you branched, you may get a merge commit; if not, Git does a \"fast-forward\" (no merge commit). After merging, the current branch includes the other branch's commits. Once a branch is merged, you can delete it locally with **git branch -d <name>** to keep your branch list tidy; the commits remain in the history of the branch you merged into.",
        "whyImportant": "Merging is how you bring feature work back into the main line. Understanding merge vs. fast-forward helps you keep history clear. Deleting merged branches avoids clutter and makes it obvious which branches are still in progress.",
        "whatToDo": [
          "Create a branch and make a commit on it (e.g. **git checkout -b feature**, edit a file—type **edit readme.txt** in the terminal, change the content in the editor below and click Save—then **git add .**, **git commit -m \"Add feature\"**)",
          "Switch to main: **git checkout main**",
          "Merge the branch: **git merge feature**",
          "Optionally delete the merged branch: **git branch -d feature** (keeps your branch list tidy)",
          "Run **git log** to see the merged history. Type **next** when done"
        ],
        "codeTemplate": "git checkout -b feature\necho \"Feature content\" > readme.txt\ngit add readme.txt\ngit commit -m \"Add feature\"\ngit checkout main\ngit merge feature\ngit branch -d feature"
      },
      "branch-3": {
        "title": "Squash merging",
        "description": "A **squash merge** (**git merge --squash <branch>**) brings the other branch's changes into your **working tree** as a single set of **staged changes**, without creating a merge commit. You then commit once—so multiple commits on the other branch become one commit on the current branch. Useful for keeping history tidy.",
        "whyImportant": "Squashing turns a messy series of \"WIP\" or \"fix typo\" commits into one clear commit, which is easier to review and cite.",
        "whatToDo": [
          "You start on a branch (**feature**) that already has multiple commits. Switch to main: **git checkout main**",
          "Run **git merge --squash feature**",
          "Run **git status**—you'll see the changes staged. Then **git commit -m \"Add feature (squashed)\"** to complete",
          "*(Optional)* Delete the branch now that it's merged: **git branch -d feature**",
          "Type **next** when done"
        ],
        "codeTemplate": "git checkout main\ngit merge --squash feature\ngit commit -m \"Add feature (squashed)\"\ngit branch -d feature"
      },
      "branch-4": {
        "title": "Rebasing",
        "description": "**git rebase <branch>** moves your current branch's commits so they sit on top of the other branch. The result is a linear history: first the other branch's commits, then yours replayed. Use it to update a feature branch with the latest main, or to clean up history before merging.",
        "whyImportant": "Rebasing keeps history linear and avoids unnecessary merge commits. In DH projects it can make the evolution of a text or dataset easier to follow.",
        "whatToDo": [
          "You start on a **feature** branch that diverged from an older **main**. Main has moved on with new commits; your feature has one commit on top of the old main.",
          "Run **git rebase main** to replay your feature commit on top of the current main.",
          "Your branch's commits are now on top of main. Use **git log --oneline** to see the linear history.",
          "You can keep working on your feature branch and rebase from **main** often to stay up to date.",
          "Type **next** when done"
        ],
        "codeTemplate": "git rebase main\ngit log --oneline"
      },
      "branch-5": {
        "title": "Merge conflicts",
        "description": "When two branches change the **same part** of the same file, Git cannot merge automatically. You get a **merge conflict**: the file is marked with conflict markers (**<<<<<<<**, **=======**, **>>>>>>>**) showing the two versions. To resolve it: open the file, decide what the final content should be (keep one version, combine both, or edit by hand), then remove the conflict markers, the **HEAD** and branch-name lines (e.g. **feature**), and the content from the version you don't want—keeping only the final text you want. Then **git add** the file and **git commit** to complete the merge. In this simulation, to open a file for editing: type **edit filename** in the terminal; the editor opens below—edit the content and click Save. Conflicts are normal when several people edit the same lines; resolving them is a routine part of collaboration.",
        "whyImportant": "In DH projects, multiple editors or datasets can touch the same files. Knowing how to read conflict markers and resolve conflicts lets you merge branches and pull others' work without fear.",
        "whatToDo": [
          "**readme.txt** already has a conflict. Run **cat readme.txt** to see the conflict markers",
          "Type **edit readme.txt** in the terminal—the editor opens below. Remove the conflict markers (<<<<<<<, =======, >>>>>>>), the **HEAD** and **feature** (branch) lines, and the content from the version you don't want. Keep only the final content you want (one version, the other, or a combination). Click **Save**",
          "Stage the resolved file: **git add readme.txt**",
          "Complete the merge: **git commit -m \"Resolve conflict\"**",
          "Type **next** when done"
        ],
        "codeTemplate": "cat readme.txt\nedit readme.txt\ngit add readme.txt\ngit commit -m \"Resolve conflict\""
      },
      "gh-1": {
        "title": "What is GitHub?",
        "description": "GitHub is a website that hosts Git repositories in the cloud. It gives you a backup of your repo, a visible history online, and tools for collaboration: others can clone your repo, suggest changes (pull requests), and you can manage issues and documentation. GitHub is very common in open source and in DH.",
        "whyImportant": "Git is local; GitHub is remote. Together they let you back up your work, share it, and collaborate. Many DH projects publish their data and code on GitHub for transparency and reuse.",
        "whatToDo": [
          "Read the section above. (You can sign up at https://github.com on your own computer later.)",
          "In the terminal, type **next** when ready to continue"
        ]
      },
      "gh-2": {
        "title": "Creating a repository on GitHub",
        "description": "On GitHub, you'd click \"New repository\", choose a name (e.g. my-dh-project), and get a URL to connect your local repo. In a real workflow you create this repo first, then use its URL in git remote and git push. You can try this on github.com later; for this lesson we focus on the idea.",
        "whyImportant": "The remote repo on GitHub is the place your local history will be copied to when you push. Creating it first gives you the URL you need for the next step.",
        "whatToDo": [
          "Read the steps above (you can create a real repo on GitHub later from your computer)",
          "In the terminal, type **next** when done"
        ]
      },
      "gh-3": {
        "title": "Pushing your code: git remote and git push",
        "description": "To send your local commits to GitHub, you link your repo to the remote with git remote add origin <URL>, then push with git push -u origin main. Here you can run these commands in the terminal (use any URL for the simulation); the lesson completes when you run git remote add or git push.",
        "whyImportant": "Pushing is how you back up and share your work. Once set up, it becomes a simple step in your workflow.",
        "whatToDo": [
          "In the terminal: **git remote add origin https://github.com/you/repo.git** (any URL is fine for this simulation). You only set up the remote once; next time you push, it will push to origin.",
          "Then: **git push -u origin main**",
          "The lesson completes when you run the commands"
        ],
        "codeTemplate": "git remote add origin https://github.com/USER/REPO.git\ngit push -u origin main"
      },
      "gh-4": {
        "title": "Getting a copy: git clone and git pull",
        "description": "To get a full copy of someone else's repo (or your own from another computer), you'd use git clone <URL>. When you clone, Git creates a new folder (usually named after the repo) and puts the full copy there—so the cloned repo always lives in its own directory. After cloning, **cd** into that new folder (e.g. **cd repo**) to work inside the project. To update an existing copy, you run git pull. Here you can try these commands in the terminal—e.g. **git clone https://github.com/some/repo** or **git pull**—to see the simulated output.",
        "whyImportant": "Clone and pull are how you work with existing DH projects, contribute to others' work, or sync between machines. They're essential for collaboration.",
        "whatToDo": [
          "In the terminal, try **git clone https://github.com/some/repo** or **git pull**",
          "After cloning, **cd** into the repo folder (e.g. **cd repo**) so you're inside the project",
          "Type **next** when done"
        ],
        "codeTemplate": "git clone https://github.com/USER/REPO.git\ncd REPO\ngit pull"
      },
      "collab-1": {
        "title": "Collaboration and good practices for DH",
        "description": "In practice, DH teams use branches (separate lines of work) and pull requests (proposed changes for review) on GitHub. Commit often with clear messages; push regularly so work is backed up. Use a README to explain the project and, if relevant, a license so others know how they can reuse your data and code. These practices make your project understandable and citable.",
        "whyImportant": "Good version control habits make DH projects reproducible, transparent, and easier to hand off or publish. They align with open scholarship and funder expectations.",
        "whatToDo": [
          "Read the collaboration and good-practice tips above",
          "In the terminal, type **next** to continue"
        ]
      },
      "collab-2": {
        "title": "Conventional commits",
        "description": "**Conventional Commits** is a simple convention for writing clear, consistent commit messages. Messages follow the form: **type(scope): description**. Common types include **feat** (new feature), **fix** (bug fix), **docs** (documentation), **style** (formatting), **refactor** (code change that neither fixes a bug nor adds a feature), **test** (tests), and **chore** (maintenance). For example: **feat(parser): add support for CSV** or **fix: correct spelling in README**. This makes history easier to read and allows tools to generate changelogs or version bumps automatically. Learn more at the official specification: https://www.conventionalcommits.org/en/v1.0.0/",
        "whyImportant": "Structured commit messages help teams (and future you) understand what changed and why. They align with Semantic Versioning and are widely used in open source and DH projects.",
        "whatToDo": [
          "Read about conventional commits above",
          "Visit [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) to explore the full specification",
          "Type **next** when you're ready to continue"
        ]
      },
      "collab-3": {
        "title": "Next steps: install Git, GitHub, and authentication",
        "description": "This tutorial runs in the browser. To use Git and GitHub on your own computer: (1) **Install Git** from https://git-scm.com/ (or your package manager). (2) **Create a GitHub account** at https://github.com if you don't have one. (3) **Set up authentication** so you can push and pull: either **SSH keys** (recommended) or a **personal access token** over HTTPS. GitHub's docs explain both: \"Connecting to GitHub with SSH\" and \"Managing your personal access tokens.\" Once Git is installed and authentication is set up, you can clone repos, push your work, and open pull requests from the command line or a GUI.",
        "whyImportant": "Without these steps, commands like git push will ask for credentials or fail. A few minutes of setup on your machine unlock everything you've learned here.",
        "whatToDo": [
          "Read the steps above and bookmark the links",
          "When you're ready, type **next** to finish the course and view your certificate"
        ]
      }
    },
    "glossary": {
      "version control": "A system that records changes to files over time so you can recall or compare specific versions later.",
      "repository": "A folder managed by Git, containing the project files and the full history of commits.",
      "repositories": "Folders managed by Git, each containing project files and full commit history. GitHub hosts Git repositories in the cloud.",
      "repo": "Short for repository: the folder where Git keeps your project's history.",
      "commit": "A snapshot of your project at a point in time, with a message and a unique ID. Commits form the history of the project.",
      "stage": "To mark files as ready to be included in the next commit (using git add).",
      "staged": "Marked as ready to be included in the next commit (using git add).",
      "staged changes": "Changes that you have added with git add and that will be included in the next commit. git status shows them under \"Changes to be committed\".",
      "push": "To send your local commits to a remote repository (e.g. on GitHub).",
      "pull": "To fetch and merge changes from a remote repository into your current branch.",
      "clone": "To download a copy of a repository (including its history) from a remote server.",
      "clones": "Copies of a repository (including its full history) downloaded from a remote server. You might clone once per machine or per working copy.",
      "remote": "A version of the repository hosted elsewhere (e.g. on GitHub), often named origin.",
      "remotes": "Versions of the repository hosted elsewhere (e.g. on GitHub). A repo can have multiple remotes; the default is often named origin.",
      "origin": "The default name for the remote repository (usually on GitHub) that your local repo is linked to.",
      "Git": "A free, open-source tool for version control on your computer. It keeps the full history of your project in a repository and works locally; you only need the internet to share or back up (e.g. via GitHub).",
      "GitHub": "A web platform that hosts Git repositories and provides tools for collaboration, issues, and documentation.",
      "Digital Humanities": "Research and teaching that combine computational methods with humanities disciplines; often involves texts, datasets, and code that benefit from version control.",
      "DH": "Abbreviation for Digital Humanities.",
      "branch": "A separate line of development in a Git repository. You can create branches to try changes or work on features without affecting the main line.",
      "branches": "Separate lines of development in a Git repository. You can create branches to try changes or work on features without affecting the main line.",
      "merge": "To combine the commits from another branch into your current branch (e.g. git merge feature).",
      "merge conflict": "When two branches modify the same part of the same file, Git cannot merge automatically. The file is marked with conflict markers (<<<<<<<, =======, >>>>>>>) and HEAD/branch-name lines; you edit the file to choose the final content, remove the markers and the unwanted branch content, then git add and git commit to complete the merge.",
      "merge commit": "A commit that records the merging of two branches when they have diverged (no fast-forward).",
      "fast-forward": "When merging, if the current branch has not diverged, Git simply moves the branch pointer forward; no merge commit is created.",
      "squash merge": "A merge that brings another branch's changes as a single set of staged changes, without a merge commit. You then make one commit, so multiple commits become one.",
      "rebase": "To move your branch's commits so they sit on top of another branch, producing a linear history. Use git rebase <branch>.",
      "pull request": "On GitHub, a proposal to merge changes from one branch into another, for review and discussion before merging.",
      "pull requests": "On GitHub, proposals to merge changes from one branch into another, for review and discussion before merging.",
      "collaboration": "Working with others on the same project. GitHub provides tools for collaboration: others can clone your repo, open pull requests, and discuss in issues.",
      "collaborate": "To work with others on the same project (e.g. by sharing a repo on GitHub, reviewing pull requests, and discussing in issues).",
      "documentation": "Written explanation of a project: what it does, how to use it, how to contribute. On GitHub, README files and wikis provide documentation.",
      "cloud": "Services and storage on the internet rather than on your own computer. GitHub hosts Git repositories in the cloud so you can back up and share them.",
      "README": "A file (usually README.md) that explains a project: what it is, how to use it, and how to contribute. Often displayed on GitHub.",
      "untracked": "A file that Git is not yet tracking (not in the last snapshot and not staged). git status lists untracked files.",
      ".gitignore": "A file in the root of your repo that lists patterns (one per line). Git ignores matching files: they won't show as untracked and won't be added with git add .",
      "secrets": "Sensitive data such as passwords, API keys, or tokens that must not be committed to the repository. List patterns for them in .gitignore so they never get added.",
      "API keys": "Credentials that let software access an external API or service. They must be kept private and never committed; add patterns for them in .gitignore.",
      "tokens": "In authentication, a credential (e.g. a personal access token or session token) used to prove identity. Keep tokens private and never commit them; list them in .gitignore.",
      "passwords": "Secret strings used to authenticate a user or service. Never commit passwords to a repository; use .gitignore to exclude files that contain them.",
      "build outputs": "Files generated by a build or compile step (e.g. compiled code, bundled assets). They can be recreated from source and should not be committed; list them in .gitignore.",
      "local config": "Configuration files that are specific to your machine or environment (e.g. local paths, debug settings). Often listed in .gitignore so each developer keeps their own copy locally.",
      "amend": "To change the last commit. git commit --amend -m \"New message\" replaces the message; with staged changes, it folds them into that commit.",
      "snapshot": "A point-in-time copy of your project. In Git, each commit is a snapshot of the tracked files.",
      "main": "The default branch name in many Git repositories. The primary line of development; feature branches are often merged back into main.",
      "working tree": "The directory containing your project files as they appear on disk. Changes you make exist in the working tree until you stage and commit them.",
      "conflict markers": "The symbols Git inserts into a file during a merge conflict: <<<<<<<, =======, >>>>>>>. You remove them when resolving the conflict.",
      "checkout": "To switch to another branch (e.g. git checkout main) or to restore a file. git checkout -b <name> creates and switches to a new branch.",
      "upstream": "The remote branch that your current branch tracks. Setting it (e.g. with git push -u origin main) links your branch to the remote.",
      "license": "A file or notice that states how others may use, share, or modify your project's code and data.",
      "modified": "A file that has been changed since the last commit. git status lists modified files (and whether they are staged or not).",
      "unstage": "To remove a file from the staging area so it will not be included in the next commit (e.g. git restore --staged <file>).",
      "open source": "Software or projects whose source code (or data) is made available for use, modification, and sharing, often under a license.",
      "issues": "On GitHub, a way to track tasks, bugs, and discussions for a repository. Others can open issues to suggest changes or report problems.",
      "authentication": "The process of proving your identity to GitHub so you can push and pull. Common methods: SSH keys (recommended) or a personal access token over HTTPS.",
      "SSH keys": "A secure way to authenticate with GitHub without typing a password each time. You generate a key pair on your computer and add the public key to your GitHub account.",
      "personal access token": "A password-like credential for HTTPS that lets you push and pull from GitHub. You create it in GitHub settings and use it instead of your account password.",
      "staging area": "The place where Git keeps the files you've added with git add, ready for the next commit. Also called the index. git status shows what is staged.",
      "history": "The sequence of commits in a repository. git log shows the history; each commit points to its parent(s).",
      "local": "On your own computer. A local repository is the copy on your machine; local commits are those not yet pushed to a remote.",
      "tracked": "A file that Git is tracking—it was in the last commit or has been added with git add. Untracked files are not yet in the repository.",
      "commit message": "The short description you give when committing (e.g. with -m \"Your message\"). Good messages help you and others understand the history later.",
      "workflow": "The way you use Git day to day: edit files, git add, git commit, and (when sharing) git push or git pull.",
      "resolve": "To fix a merge conflict by editing the file, choosing the final content, removing conflict markers and the HEAD/branch lines and unwanted version, then staging and committing.",
      "reproducibility": "The ability for others (or future you) to recreate or cite a specific state of a project. Version control supports reproducibility.",
      "transparency": "Making the history of changes visible and traceable. Funders and publishers often expect version control for transparency.",
      ".git": "The hidden folder inside your project where Git stores the repository (all commits, branches, and metadata). Created by git init.",
      "feature branch": "A branch used to develop a single feature or change, often merged back into main when done. Keeps main stable.",
      "diverged": "When two branches have different commits—e.g. you made commits on main while someone else made commits on another branch. Merging may create a merge commit.",
      "discard": "To throw away uncommitted changes in a file (e.g. git restore <file>). The file returns to the last committed version. Use with care.",
      "linear history": "A history where commits follow a single line, with no merge commits. Rebase can produce a linear history.",
      "open scholarship": "The practice of making research, data, and code openly accessible and reusable. Good version control and documentation (e.g. README, license) support open scholarship.",
      "citable": "Able to be cited; a project with clear version history, README, and license is easier for others to cite and credit.",
      "reproducible": "Able to be recreated or repeated; version control helps make DH projects reproducible by preserving a clear history of changes.",
      "transparent": "Making the history of changes visible and traceable; version control provides transparency for funders and collaborators.",
      "HTTPS": "Hypertext Transfer Protocol Secure; the encrypted protocol used for web and Git traffic. GitHub supports HTTPS for clone, push, and pull; you authenticate with a personal access token.",
      "repos": "Short for repositories: the project folders you clone, push to, or pull from.",
      "command line": "The text-based interface where you type commands (e.g. git push, git clone). Also called terminal or shell.",
      "GUI": "Graphical user interface; a program with windows, buttons, and menus. Git GUI tools (e.g. GitHub Desktop, GitKraken) let you clone, commit, and push without typing commands.",
      "@mention": "To notify a person on GitHub by using @ before their username. Users in an organization on GitHub can also be a part of a team that can be mentioned.",
      "access token": "A token that is used in place of a password when performing Git operations over HTTPS with Git on the command line or the API. Also called a personal access token.",
      "API preview": "A way to try out new APIs and changes to existing API methods before they become part of the official GitHub API.",
      "appliance": "A software application combined with just enough operating system (JeOS) to run optimally on industry-standard hardware (typically a server) or in a virtual machine.",
      "assignee": "The user that is assigned to an issue.",
      "authentication code": "A code you'll supply, in addition to your GitHub password, when signing in with 2FA via the browser. Also called a \"2FA authentication code.\"",
      "base branch": "The branch into which changes are combined when you merge a pull request. When you create a pull request, you can change the base branch from the repository's default branch to another branch if required.",
      "basic authentication": "A method of authentication where the credentials are sent as unencrypted text.",
      "billing cycle": "The interval of time for your specific billing plan.",
      "billing email": "The organization email address where GitHub sends receipts, credit card or PayPal charges, and other billing-related communication.",
      "billing manager": "The organization member that manages billing settings for an organization.",
      "billing plan": "Payment plans for users and organizations that include set features for each type of plan.",
      "bio": "The user-generated description found on a profile.",
      "blame": "The \"blame\" feature in Git describes the last modification to each line of a file, which generally displays the revision, author and time.",
      "block": "To remove a user's ability to collaborate on an organization's repositories.",
      "branch restriction": "A restriction that repository admins can enable so that only certain users or teams can push or make certain changes to the branch.",
      "Business plan": "An organization billing plan where you can collaborate on unlimited public and private repositories, allow or require organization members to authenticate to GitHub using SAML SSO, and provision and deprovision access with SAML or SCIM.",
      "CA certificate": "A digital certificate issued by Certificate Authority (CA) that ensures there are valid connections between two machines, such as a user's computer and GitHub.com and verifies the ownership of a site.",
      "card": "A movable square within a project board associated with an issue or pull request.",
      "check": "A check is a type of status check on GitHub. See Status checks.",
      "cherry-picking": "To choose a subset of changes from a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the git cherry-pick command.",
      "child team": "Within nested teams, the subteam that inherits the parent team's access permissions and @mentions.",
      "clean": "A working tree is clean if it corresponds to the revision referenced by the current HEAD. Also see dirty.",
      "clustering": "The ability to run GitHub Enterprise services across multiple nodes and load balance requests between them.",
      "code frequency graph": "A repository graph that shows the content additions and deletions for each week in a repository's history.",
      "code of conduct": "A document that defines standards for how to engage in a community.",
      "code owner": "A person who is designated as an owner of a portion of a repository's code. The code owner is automatically requested for review when someone opens a pull request that makes changes to code the code owner owns.",
      "collaborator": "A collaborator is a person with read and write access to a repository who has been invited to contribute by the repository owner.",
      "commit author": "The user who makes the commit.",
      "commit graph": "A repository graph that shows all the commits made to a repository in the past year.",
      "commit ID": "Also known as SHA. A 40-character checksum hash that identifies the commit.",
      "compare branch": "The branch you use to create a pull request. This branch is compared to the base branch you choose for the pull request. Also known as the \"head branch\" of the pull request.",
      "continuous integration": "Also known as CI. A process that runs automated builds and tests once a person commits a change to a configured repository on GitHub.",
      "contribution graph": "The part of a user's profile that shows their contributions over a period of up to one year, day by day.",
      "contribution guidelines": "A document explaining how people should contribute to your project.",
      "contributions": "Specific activities on GitHub that add a square to a user's contribution graph or add activities to a user's timeline on their profile.",
      "contributor": "A contributor is someone who does not have collaborator access to a repository but has contributed to a project and had a pull request they opened merged into the repository.",
      "contributors graph": "A repository graph that displays the top 100 contributors to a repository.",
      "coupon": "A GitHub-provided code that users or organizations can use to pay for all or part of their subscription.",
      "cron": "A time-based job scheduler in Unix-like computer operating systems.",
      "cURL": "Used in command lines or scripts to transfer data.",
      "dashboard": "Your personal dashboard is the main hub of your activity on GitHub. From it you can keep track of issues and pull requests, navigate to your top repositories and team pages, and learn about recent activity.",
      "default branch": "The base branch for new pull requests and code commits in a repository. Each repository has at least one branch; the first branch is usually called main.",
      "dependency graph": "A repository graph that shows the packages and projects that the repository depends on.",
      "dependents graph": "A repository graph that shows the packages, projects, and repositories that depend on a public repository.",
      "deploy key": "A deploy key is an SSH key that is stored on your server and grants access to a single GitHub repository. This key is attached directly to the repository instead of to a personal user account.",
      "detached HEAD": "Git will warn you if you're working on a detached HEAD, which means that Git is not pointing to a branch and that any commits you make will not appear in commit history.",
      "diagnostics": "An overview of a GitHub Enterprise instance's settings and environment.",
      "diff": "A diff is the difference in changes between two commits, or saved changes. The diff will visually describe what was added or removed from a file since its last commit.",
      "directory": "A folder containing one or more files or folders. You can create directories to organize the contents of a repository.",
      "dirty": "A working tree is considered \"dirty\" if it contains modifications that have not been committed to the current branch.",
      "email notifications": "Notifications sent to a user's email address.",
      "enterprise account": "Enterprise accounts allow you to centrally manage policy and billing for multiple organizations.",
      "Explorer": "An instance of GraphiQL, which is a \"graphical interactive in-browser GraphQL IDE.\"",
      "fetch": "When you use git fetch, you're adding changes from the remote repository to your local working branch without committing them. Unlike git pull, fetching allows you to review changes before committing them to your local branch.",
      "fenced code block": "An indented block of code you can create with GitHub Flavored Markdown using triple backticks before and after the code block.",
      "following (users)": "To get notifications about another user's contributions and activity.",
      "force push": "A Git push that overwrites the remote repository with local changes without regard for conflicts.",
      "fork": "A fork is a personal copy of another user's repository that lives on your account. Forks allow you to freely make changes to a project without affecting the original upstream repository. You can also open a pull request in the upstream repository and keep your fork synced with the latest changes.",
      "Free plan": "A user account billing plan that is free. Users can collaborate on unlimited public repositories with unlimited collaborators.",
      "gist": "A gist is a shareable file that you can edit, clone, and fork on GitHub. You can make a gist public or secret.",
      "gitfile": "A plain .git file, which is always at the root of a working tree and points to the Git directory, which has the entire Git repository and its meta data.",
      "GitHub App": "GitHub Apps provide a service to an entire organization and use their own identity when performing their function. They can be installed directly on organizations and user accounts and granted access to specific repositories.",
      "GitHub Flavored Markdown": "GitHub-specific Markdown used to format prose and code across GitHub.",
      "GitHub Importer": "A tool that quickly imports source code repositories, including commits and revision history, to GitHub for users.",
      "GitHub Jobs": "A GitHub site where employers can post jobs that GitHub users may be interested in.",
      "GitHub Marketplace": "A subsite for GitHub users and organizations to purchase and install applications that extend and complement their workflow.",
      "GitHub Pages": "Also referred to as Pages. A static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository.",
      "GitHub Wiki": "A section for hosting wiki style documentation on a GitHub repository.",
      "GraphQL": "A query language for APIs and a runtime for fulfilling those queries with your existing data.",
      "HEAD": "A defined commit of a branch, usually the most recent commit at the tip of the branch.",
      "head branch": "The branch whose changes are combined into the base branch when you merge a pull request. Also known as the \"compare branch.\"",
      "Hello, World": "A \"Hello, World!\" program is a computer program that outputs or displays \"Hello, World!\" to a user. Often used as an example of a programming language's basic syntax.",
      "high-availability": "A system or component that is continuously operational for a desirably long length of time.",
      "hook": "During the normal execution of several Git commands, call-outs are made to optional scripts that allow a developer to add functionality or checking.",
      "hostname": "Human-readable nicknames that correspond to the address of a device connected to a network.",
      "identicon": "An auto-generated image used as a default profile picture when users sign up for GitHub. Users can replace their identicon with their own profile picture.",
      "identity provider": "Also known as an IdP. A trusted provider that lets you use SAML single sign-on (SSO) to access other websites.",
      "instance": "An organization's private copy of GitHub contained within a virtual machine that they configure and control.",
      "integration": "A third-party application that integrates with GitHub. These are often GitHub Apps, GitHub Actions, or custom actions.",
      "issue": "Issues are suggested improvements, tasks or questions related to the repository. Issues can be created by anyone (for public repositories), and are moderated by repository collaborators. Each issue contains its own discussion thread.",
      "Jekyll": "A static site generator for personal, project, or organization sites.",
      "Jekyll Theme Chooser": "An automated way to select a visual theme for your Jekyll site without editing or copying CSS files.",
      "key fingerprint": "A short sequence of bytes used to identify a longer public key.",
      "keychain": "A password management system in macOS.",
      "keyword": "A specific word that closes an issue when used within a pull request.",
      "label": "A tag on an issue or pull request. Repositories come with a handful of default labels, but users can create custom labels.",
      "LFS": "Git Large File Storage. An open source Git extension for versioning large files.",
      "line comment": "A comment within a pull request on a specific line of code.",
      "line ending": "An invisible character or characters that symbolize the end of a line in a text file.",
      "Linguist": "A library used on GitHub to detect blob languages, ignore binary or vendored files, suppress generated files in diffs, and generate language breakdown graphs.",
      "locked personal account": "A personal account that cannot be accessed by the user. Accounts are locked when users downgrade their paid account to a free one, or if their paid plan is past due.",
      "management console": "A section within the GitHub Enterprise interface that contains administrative features.",
      "Markdown": "Markdown is an incredibly simple semantic file format. GitHub supports Markdown and uses a particular form of Markdown called GitHub Flavored Markdown.",
      "markup": "A system for annotating and formatting a document.",
      "master": "The default branch in many Git repositories. By default, when you create a new Git repository on the command line, a branch called master is created. Many tools now use main as the default branch name.",
      "members graph": "A repository graph that shows all the forks of a repository.",
      "mention": "A notification sent to a user by prefacing their username with the @ symbol. Users in an organization on GitHub can also be a part of a team that can be mentioned.",
      "milestone": "A way to track the progress on groups of issues or pull requests in a repository.",
      "mirror": "A new copy of a repository.",
      "nested team": "A child team of a parent team. You can have multiple children (or nested) teams.",
      "network graph": "A repository graph that shows the branch history of the entire repository network, including branches of the root repository and branches of forks that contain commits unique to the network.",
      "news feed": "An activity view of repositories or people you watch. An organization's News Feed shows activity on repositories owned by the organization.",
      "non-fast-forward": "When your local copy of a repository is out-of-sync with the upstream repository and you need to fetch the upstream changes before you push your local changes.",
      "notification": "Updates, delivered by either the web or email depending on your settings, that give you information about the activities you're interested in.",
      "OAuth app": "A third-party application that uses access tokens rather than passwords to access information for users.",
      "OAuth token": "The access token used by OAuth apps to access information for users.",
      "organization": "Organizations are a group of two or more users that typically mirror real-world organizations. They are administered by users and can contain both repositories and teams.",
      "organization owner": "Users who have full administrative access to the organization they own.",
      "outside collaborator": "A user who has been given access to one or more of an organization's repositories, but has no other access to the organization and is not a member of the organization.",
      "owner": "Organization members that have complete administrative access to the organization.",
      "parent team": "Within nested teams, the main team from which child teams inherit access permissions and @mentions.",
      "participating notifications": "A notification about an update in a conversation in an issue or pull request where your username or team was mentioned or where you have previously replied in a comment.",
      "permalink": "A permanent static hyperlink to a particular web page.",
      "personal account": "A GitHub account that belongs to an individual user.",
      "pinned repository": "A repository that a user has decided to display prominently on their profile.",
      "pre-receive hooks": "Scripts that run on the GitHub Enterprise server that you can use to implement quality checks.",
      "primary email address": "The main email address where GitHub sends receipts, credit card or PayPal charges, and other billing-related communication.",
      "private contributions": "Contributions made to a private (vs. public) repository.",
      "private repository": "Private repositories are only visible to the repository owner and collaborators that the owner specified.",
      "production branch": "A branch with final changes that are ready to be used or deployed to an application or site.",
      "profile": "The page that shows information about a user's activity on GitHub.",
      "profile picture": "A custom image users upload to GitHub to identify their activity, usually along with their username. Also referred to as an avatar.",
      "project board": "Boards within GitHub that are made up of issues, pull requests, and notes that are categorized as cards in columns.",
      "protected branch": "Protected branches block several features of Git on a branch that a repository administrator chooses to protect. They can't be force pushed, deleted, or have changes merged without required checks passing or required reviews approved.",
      "public contributions": "Contributions made to a public (vs. private) repository.",
      "public repository": "A public repository can be viewed by anyone, including people who aren't GitHub users.",
      "pull access": "A synonym for read access.",
      "pull request review": "Comments from collaborators on a pull request that approve the changes or request further changes before the pull request is merged.",
      "pulse graph": "A repository graph that gives you an overview of a repository's activity.",
      "punch graph": "A repository graph that shows the frequency of updates to a repository based on the day of week and time of day.",
      "push a branch": "When you successfully push a branch to a remote repository, you update the remote branch with changes from your local branch. If the remote HEAD is not an ancestor to the local HEAD, the push fails.",
      "push access": "A synonym for write access.",
      "read access": "A permission level on a repository that allows the user to pull, or read, information from the repository. All public repositories give read access to all GitHub users. A synonym for pull access.",
      "recovery code": "A code that helps you regain access to your GitHub account.",
      "release": "GitHub's way of packaging and providing software to your users.",
      "remote repository": "A repository that is used to track the same project but resides somewhere else.",
      "remote URL": "The place where your code is stored: a repository on GitHub, another user's fork, or even a different server.",
      "replica": "A GitHub Enterprise instance that provides redundancy for the primary GitHub Enterprise instance.",
      "repository cache": "A read-only mirror of repositories for your GitHub Enterprise server instance, located near distributed teams and CI clients.",
      "repository graph": "A visual representation of your repository's data.",
      "repository maintainer": "Someone who manages a repository. This person may help triage issues and use labels and other features to manage the work of the repository.",
      "required pull request review": "Required reviews ensure that pull requests have at least one approved review before collaborators can make changes to a protected branch.",
      "required status check": "Checks on pull requests that ensure all required CI tests are passing before collaborators can make changes to a protected branch.",
      "revert": "When you revert a pull request on GitHub, a new pull request is automatically opened, which has one commit that reverts the merge commit from the original merged pull request. In Git, you can revert commits with git revert.",
      "review": "Reviews allow others with access to your repository to comment on the changes proposed in pull requests, approve the changes, or request further changes before the pull request is merged.",
      "root directory": "The first directory in a hierarchy.",
      "root filesystem": "The base operating system and the GitHub Enterprise application environment.",
      "saved reply": "A comment you can save and add to your GitHub user account so that you can use it across GitHub in issues and pull requests.",
      "scope": "Named groups of permissions that an OAuth app or personal access token (classic) can request to access both public and non-public data.",
      "seat": "A user within a GitHub Enterprise organization. This may be referred to as \"seat count.\"",
      "secret team": "A team that is only visible to the other people on the team and people with owner permissions.",
      "security log": "A log that lists the last 50 actions or those performed within the last 90 days.",
      "server-to-server request": "An API request used by an application that acts as a bot, independently of any particular user. The token used is acquired programmatically, via the GitHub API.",
      "service hook": "Also called \"webhook.\" Webhooks provide a way for notifications to be delivered to an external web server whenever certain actions occur on a repository or organization.",
      "single sign-on": "Also called SSO. Allows users to sign in to a single location - an identity provider (IdP) - that then gives the user access to other service providers.",
      "squash": "To combine multiple commits into a single commit. Also a Git command.",
      "SSH key": "SSH keys are a way to identify yourself to an online server, using an encrypted message. GitHub uses SSH keys to securely transfer information to your computer.",
      "staging instance": "A way to test modifications before they are applied to your actual GitHub Enterprise instance.",
      "star": "A bookmark or display of appreciation for a repository. Stars are a manual way to rank the popularity of projects.",
      "status": "A visual representation within a pull request that your commits meet the conditions set for the repository you're contributing to.",
      "status checks": "Status checks are external processes, such as continuous integration builds, which run for each commit you make in a repository.",
      "subscription": "A user or organization's GitHub plan.",
      "team": "A group of organization members that reflect your company or group's structure with cascading access permissions and mentions.",
      "team maintainer": "Organization members that have a subset of permissions available to organization owners to manage teams.",
      "Team plan": "An organization billing plan that gives you unlimited public and private repositories.",
      "timeline": "A series of events in a pull request or on a user profile.",
      "topic branch": "A regular Git branch that is used by a developer to identify a conceptual line of development. Can also be called a feature branch.",
      "topics": "A way to explore repositories in a particular subject area, find projects to contribute to, and discover new solutions to a specific problem on GitHub.",
      "traffic graph": "A repository graph that shows a repository's traffic, including full clones (not fetches), visitors from the past 14 days, referring sites, and popular content.",
      "transfer": "To transfer a repository means to change the owner of a repository. The new owner will be able to immediately administer the repository's contents, issues, pull requests, releases, and settings.",
      "upstream branch": "The default branch that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.<name>.remote and branch.<name>.merge. If the upstream branch of A is origin/B sometimes we say \"A is tracking origin/B.\"",
      "user": "Users are people with personal GitHub accounts. Each user has a personal profile, and can own multiple repositories, public or private.",
      "user-to-server request": "An API request used by an application that performs a task on behalf of a particular user. The token used is acquired via OAuth.",
      "username": "A user's handle on GitHub.",
      "visible team": "A team that can be viewed and @mentioned by every organization member.",
      "watch": "You can watch a repository or issue to receive notifications when updates are made to an issue or pull request.",
      "watching notifications": "A notification about activity in a repository a user has subscribed to.",
      "web notifications": "Notifications displayed in the web interface on GitHub.",
      "webhooks": "Webhooks allow you to build or set up GitHub Apps which subscribe to certain events on GitHub.com. Webhooks provide a way for notifications to be delivered to an external web server whenever certain actions occur on a repository or organization. Also called a service hook.",
      "write access": "A permission level on a repository that allows the user to push, or write, changes to the repository."
    },
    "cheatsheet": {
      "sections": [
        {
          "title": "1. Version control",
          "paragraphs": [
            "What it is: A way to save and track changes to your files over time. One project, one history of every change: who changed what, and when. You can go back to any earlier version.",
            "Why it matters: Without it, you can lose work, overwrite others' changes, or forget what you changed. With it, you have a clear history and can collaborate safely.",
            "For Digital Humanities: Editions, corpora, datasets, and websites often involve teams, years of iteration, and the need to cite or reproduce a specific state. Many funders and publishers expect or recommend version control for transparency and reproducibility."
          ]
        },
        {
          "title": "2. Git basics",
          "subsections": [
            {
              "title": "What is Git?",
              "list": [
                "Free, open-source tool for version control on your computer.",
                "Runs locally: full history lives in a hidden folder (a repository) inside your project.",
                "No internet needed to make commits—only when you share or back up (e.g. with GitHub)."
              ]
            },
            {
              "title": "Essential commands",
              "items": [
                { "cmd": "git init", "desc": "Turn the current folder into a Git repository" },
                { "cmd": "git add <file> or git add .", "desc": "Stage files for the next commit" },
                { "cmd": "git commit -m \"Your message\"", "desc": "Create a snapshot with a short message" },
                { "cmd": "git status", "desc": "See modified, staged, and untracked files" },
                { "cmd": "git log", "desc": "View commit history" },
                { "cmd": "git log --oneline", "desc": "Compact one-line view of history" }
              ]
            },
            {
              "title": "Workflow",
              "list": [
                "Create or edit files.",
                "git add the files you want to include.",
                "git commit -m \"Clear, short message\".",
                "Use git status often to avoid committing the wrong files."
              ]
            },
            {
              "title": ".gitignore",
              "list": [
                "A file that lists patterns (one per line). Git ignores matching files: they won't show as untracked and won't be added with git add .",
                "Use it for: secrets, API keys, build outputs, local config, caches, editor backups.",
                "Create with: edit .gitignore (in the tutorial) or any text editor. Commit .gitignore so the rules are shared."
              ]
            },
            {
              "title": "Fixing mistakes",
              "items": [
                { "cmd": "git restore --staged <file>", "desc": "Unstage a file (remove from the next commit)" },
                { "cmd": "git restore <file>", "desc": "Discard uncommitted changes in that file (use with care)" },
                { "cmd": "git commit --amend -m \"New message\"", "desc": "Replace the last commit's message (or add more staged changes into it)" },
                { "cmd": "git reset --soft HEAD~1", "desc": "Undo last commit but keep changes staged" }
              ]
            }
          ]
        },
        {
          "title": "3. Branching",
          "paragraphs": [
            "Branch: A separate line of development. You can try changes or work on features without affecting the main line.",
            "Why: Essential for trying ideas, working on features separately, and collaborating. In DH you might use a branch for a new edition variant or dataset update."
          ],
          "subsections": [
            {
              "title": "Commands",
              "items": [
                { "cmd": "git branch", "desc": "List branches (* = current)" },
                { "cmd": "git checkout -b <name>", "desc": "Create and switch to a new branch" },
                { "cmd": "git checkout <name>", "desc": "Switch to an existing branch" },
                { "cmd": "git merge <branch>", "desc": "Merge that branch into the current branch" },
                { "cmd": "git merge --squash <branch>", "desc": "Bring the other branch's changes as one set of staged changes; you then commit once (no merge commit)" },
                { "cmd": "git rebase <branch>", "desc": "Move your commits so they sit on top of the other branch (linear history)" },
                { "cmd": "git branch -d <name>", "desc": "Delete a merged branch (keeps the list tidy)" }
              ]
            },
            {
              "title": "Merge conflicts",
              "list": [
                "When two branches change the same part of the same file, Git cannot merge automatically.",
                "The file is marked with conflict markers: <<<<<<<, =======, >>>>>>>.",
                "Resolve: Open the file, choose the final content (keep one version, combine, or edit), remove the conflict markers, the HEAD and branch-name lines, and the version you don't want, then git add the file and git commit."
              ]
            }
          ]
        },
        {
          "title": "4. GitHub",
          "paragraphs": [
            "What it is: A website that hosts Git repositories in the cloud. Backup, visible history, and tools for collaboration: others can clone, suggest changes (pull requests), and you can manage issues and documentation.",
            "Relation: Git is local; GitHub is remote. Together they let you back up, share, and collaborate."
          ],
          "subsections": [
            {
              "title": "Creating a repo on GitHub",
              "list": [
                "On GitHub: New repository → choose a name (e.g. my-dh-project) → you get a URL to connect your local repo."
              ]
            },
            {
              "title": "Remote and push/pull",
              "items": [
                { "cmd": "git remote add origin <URL>", "desc": "Link your local repo to the remote (e.g. GitHub)" },
                { "cmd": "git push -u origin main", "desc": "First push: send commits and set upstream" },
                { "cmd": "git push", "desc": "Send your commits to the remote" },
                { "cmd": "git pull", "desc": "Fetch and merge changes from the remote" },
                { "cmd": "git clone <URL>", "desc": "Download a full copy of a repository (creates a new folder)" }
              ]
            },
            {
              "title": "Tip",
              "paragraphs": ["Run git pull before git push to avoid rejections when others have pushed."]
            }
          ]
        },
        {
          "title": "5. Collaboration and good practices",
          "list": [
            "Use branches for separate lines of work; use pull requests on GitHub to propose and review changes before merging.",
            "Commit often with clear, short messages. Consider Conventional Commits (e.g. feat:, fix:, docs:) for consistency—see https://www.conventionalcommits.org/en/v1.0.0/.",
            "Push regularly so work is backed up.",
            "Add a README (e.g. README.md) to explain the project and how to use or contribute.",
            "Add a license so others know how they can reuse your data and code.",
            "One branch per feature or fix, then merge when ready."
          ]
        },
        {
          "title": "6. Command cheatsheet (quick reference)",
          "subsections": [
            { "title": "Setup", "code": "git config user.name \"Your Name\"\ngit config user.email \"your@email.com\"\ngit init" },
            { "title": "Basic workflow", "code": "git status\ngit add <file>    # or git add .\ngit commit -m \"message\"\ngit log" },
            { "title": "Branches", "code": "git branch\ngit checkout -b <branch>\ngit checkout <branch>\ngit merge <branch>\ngit merge --squash <branch>\ngit rebase <branch>\ngit branch -d <branch>" },
            { "title": "Remote (GitHub)", "code": "git remote add origin <URL>\ngit push -u origin main\ngit push\ngit pull\ngit clone <URL>" },
            { "title": "Useful", "code": "git log --oneline\ngit remote -v\ngit restore --staged <file>\ngit restore <file>\ngit commit --amend -m \"New message\"" }
          ]
        },
        {
          "title": "7. Key terms (glossary)",
          "items": [
            { "cmd": "Repository (repo)", "desc": "Folder managed by Git; contains project files and full commit history." },
            { "cmd": "Commit", "desc": "A snapshot of the project at a point in time, with a message and unique ID." },
            { "cmd": "Stage / staged", "desc": "Mark files as ready for the next commit with git add." },
            { "cmd": "Remote / origin", "desc": "The version of the repo hosted elsewhere (e.g. GitHub); origin is the default name." },
            { "cmd": "Push / Pull / Clone", "desc": "Push: send local commits to a remote. Pull: fetch and merge from remote. Clone: download a full copy of a repo." },
            { "cmd": "Branch / Merge", "desc": "Branch: separate line of development. Merge: combine another branch into the current one." },
            { "cmd": "Merge conflict", "desc": "Same part of same file changed in two branches; you resolve by editing the file, removing conflict markers and the HEAD/feature lines and unwanted branch content, then committing." },
            { "cmd": "Untracked / .gitignore", "desc": "Untracked: file Git is not yet tracking. .gitignore: file listing patterns Git should ignore." }
          ]
        },
        {
          "title": "8. Next steps (on your own computer)",
          "list": [
            "Install Git: https://git-scm.com/ (or your package manager).",
            "Create a GitHub account: https://github.com",
            "Set up authentication so you can push and pull: SSH keys (recommended), or Personal access token over HTTPS. See GitHub docs: \"Connecting to GitHub with SSH\" and \"Managing your personal access tokens.\"",
            "Once Git is installed and authentication is set up, you can clone repos, push your work, and open pull requests from the command line or a GUI."
          ],
          "paragraphs": ["Tutorial: https://humanities-data-lab.github.io/learn-git-and-github/"]
        }
      ]
    }
  },
  "fr": {
    "ui": {
      "title": "Apprendre Git et GitHub",
      "subtitle": "Contrôle de version dès le début — Essentiel pour les humanités numériques",
      "welcome": "Bienvenue dans Git et GitHub !",
      "welcomeDescription": "Ce tutoriel interactif enseigne le contrôle de version depuis les bases. Aucune connaissance préalable de Git, GitHub ou du contrôle de version n'est requise. Vous verrez pourquoi ces outils sont importants—surtout pour les projets en humanités numériques—et comment les utiliser. Tout se fait dans le terminal et l'éditeur de fichiers sur cette page : pas besoin d'utiliser le terminal de votre ordinateur ni d'installer Git.",
      "tutorialCredit": "Réalisé par Asher Lacho en coordination avec le Humanities Data Lab. Ce tutoriel reprend le même système de modules que le cours HTML/CSS. Il est disponible en anglais et en français.",
      "enterName": "Entrez votre nom",
      "chooseAvatar": "Choisissez votre avatar",
      "chooseAvatarOption": "Option d'avatar {number} sur {total}",
      "avatarPickerScrollHint": "Faites défiler pour plus d'avatars",
      "changeAvatar": "Changer d'avatar",
      "createYourAvatar": "Créez votre avatar",
      "avatarSkinTone": "Teint",
      "avatarHairStyle": "Coiffure",
      "avatarHairColor": "Couleur des cheveux",
      "avatarClothingStyle": "Type de vêtement",
      "avatarClothingColor": "Couleur du vêtement",
      "avatarMouth": "Bouche",
      "avatarEyes": "Yeux",
      "avatarAccessories": "Lunettes et accessibilité",
      "avatarAccessoriesColor": "Couleur lunettes / accessoire",
      "avatarEyebrows": "Sourcils",
      "avatarFacialHair": "Barbe / moustache",
      "avatarFacialHairColor": "Couleur barbe",
      "avatarHatColor": "Couleur chapeau / coiffe",
      "avatarClothingGraphic": "Motif du T-shirt",
      "addColor": "Ajouter une couleur",
      "addColorHint": "Cliquez sur un carré pour changer la couleur ; ajoutez-en pour donner d'autres teintes à l'avatar.",
      "removeColor": "Retirer",
      "done": "Terminé",
      "randomizeAvatar": "Avatar aléatoire",
      "startLearning": "Commencer",
      "nameCertificateNote": "Ce nom apparaîtra sur votre certificat partageable à la fin de toutes les leçons.",
      "welcomeUser": "Bienvenue, {name} ! • Leçon {current} sur {total}",
      "courseProgress": "Progression — Cliquez sur une section pour y aller",
      "whatWeLearning": "Ce que nous apprenons :",
      "whyImportant": "Pourquoi c'est important :",
      "needHint": "Besoin d'un indice ? Cliquez pour voir quoi faire",
      "hideHint": "Masquer l'indice",
      "showHint": "Afficher l'indice",
      "whatToDo": "À faire :",
      "commandsToTry": "Commande(s) à essayer",
      "copyCommand": "Copier la commande",
      "terminalHint": "Utilisez le terminal à droite pour exécuter la commande.",
      "terminalNavHint": "Commandes : ls, pwd, cd, cat, echo, edit | git ... | next | back | clear",
      "editorLabel": "Éditeur de fichier",
      "save": "Enregistrer",
      "cancel": "Annuler",
      "back": "← Retour",
      "verifyCode": "C'est fait →",
      "skip": "Passer →",
      "tryAgain": "Réessayer",
      "nextLesson": "Leçon suivante →",
      "learnMore": "En savoir plus",
      "tip": "Conseil :",
      "copyUrl": "Copiez cette URL pour sauvegarder votre progression et reprendre plus tard :",
      "copyToClipboard": "Copier dans le presse-papiers",
      "copied": "Copié !",
      "noFilesSaved": "Aucune donnée n'est enregistrée sur notre serveur—c'est le seul moyen de retrouver votre progression.",
      "certificateTitle": "Certificat de réussite",
      "certificateSubtitle": "Git et GitHub pour le contrôle de version",
      "certificateDescription": "Ceci certifie que",
      "certificateCompleted": "a suivi avec succès le tutoriel sur le contrôle de version, les bases de Git et GitHub—en mettant l'accent sur leur importance pour les humanités numériques.",
      "certificateCovered": "Ce cours a couvert :",
      "completedOn": "Terminé le",
      "congratulations": "Félicitations",
      "certificateShare": "Partagez ce certificat en copiant l'URL :",
      "certificateShareDescription": "Vous pouvez copier l'URL ci-dessus pour partager votre certificat.",
      "printCertificate": "Imprimer le certificat",
      "emailCertificate": "Envoyer le certificat par courriel",
      "emailCertificateSubject": "Mon certificat Git et GitHub",
      "emailCertificateBody": "J'ai terminé le tutoriel Git et GitHub ! Voici mon certificat :",
      "certificateItem1": "Qu'est-ce que le contrôle de version et pourquoi il compte pour les humanités numériques",
      "certificateItem2": "Bases de Git : dépôts, commits et historique",
      "certificateItemBranching": "Branches : créer, fusionner, squash et rebase",
      "certificateItem3": "GitHub : hébergement, push, pull et clone",
      "certificateItem4": "Collaboration et bonnes pratiques pour les projets en HN",
      "successMessage": "Très bien ! Passez à la leçon suivante quand vous êtes prêt.",
      "errorMessage": "Pas tout à fait. Assurez-vous de : {elements}",
      "selectLanguage": "Choisir la langue",
      "studentNameAria": "Nom de l'étudiant : {name}",
      "completed": "Terminé",
      "jumpToSection": "Aller à la section {section}. {completed} sur {total} leçons terminées.",
      "hintRegion": "Instructions de l'indice",
      "glossaryButton": "Glossaire",
      "glossaryTitle": "Glossaire",
      "glossarySearchPlaceholder": "Rechercher un terme...",
      "glossaryClose": "Fermer le glossaire",
      "glossaryNoResults": "Aucun terme ne correspond.",
      "cheatsheetButton": "Aide-mémoire",
      "cheatsheetTitle": "Aide-mémoire Git et GitHub",
      "cheatsheetPrint": "Imprimer",
      "cheatsheetClose": "Fermer",
      "skipToMainContent": "Aller au contenu principal",
      "definitionOf": "Définition de {term}",
      "backToLessons": "Retour aux leçons",
      "viewCertificate": "Voir le certificat",
      "reportBug": "Signaler un bug",
      "branchVisualizerHelpButton": "Aide",
      "branchVisualizerHelpTitle": "À propos du graphe de branches",
      "branchVisualizerHelpBody": "Ce graphe affiche vos branches et commits Git. Chaque point est un commit (avec son hash court et son message). Les branches apparaissent en lignes séparées ; la branche main et toute branche que vous créez (ex. avec git checkout -b) sont affichées. Le libellé « current » indique la branche sur laquelle vous êtes. Les nouvelles branches apparaissent dès que vous les créez, même avant d'y faire un commit.",
      "lessonCompleteNext": "Leçon terminée ! Passage à la suivante...",
      "lessonCompleteTypeNext": "Leçon terminée ! Tapez \"next\" ou cliquez sur le bouton pour continuer.",
      "goingBackToLesson": "Retour à la leçon précédente.",
      "editUsage": "edit: usage: edit <filename>",
      "editingFile": "Édition de {filename} (enregistrer ou annuler dans l'éditeur ci-dessous)",
      "editFileReminder": "Pour modifier un fichier ici : tapez **edit** suivi du nom du fichier dans le terminal (ex. **edit readme.txt**) ; l'éditeur s'ouvre en dessous—faites vos modifications et cliquez sur Enregistrer.",
      "unsupportedGitCommand": "La commande que vous avez entrée peut être valide dans Git, mais l'environnement simulé de ce tutoriel ne la prend pas en charge—nous ne couvrons qu'un sous-ensemble de commandes ici."
    },
    "categories": {
      "tutorialIntro": "Comment fonctionne ce tutoriel",
      "versionControl": "Contrôle de version",
      "gitBasics": "Bases de Git",
      "branching": "Branches",
      "github": "GitHub",
      "collaboration": "Collaboration"
    },
    "lessons": {
      "intro-1": {
        "title": "Le terminal : ce qui fonctionne comme en réel",
        "description": "Ce tutoriel propose un **terminal simulé** à droite. La plupart du temps il se comporte comme un vrai terminal (Mac, Linux ou VS Code). Vous tapez des commandes et voyez la sortie ; l’invite affiche le dossier courant (**~/my-project**). Les commandes shell habituelles fonctionnent comme attendu : **ls** liste les fichiers, **pwd** affiche le répertoire courant, **cd** change de répertoire, **cat** affiche le contenu d’un fichier, et **echo** peut créer ou compléter un fichier (ex. **echo \"Bonjour\" > readme.txt**). La façon dont vous naviguez et exécutez des commandes est donc très proche d’un vrai terminal.",
        "whyImportant": "S’habituer à taper des commandes ici facilitera le passage à un vrai terminal ou à un IDE. Les réflexes que vous prenez (lire l’invite, utiliser ls et cat pour voir ce qu’il y a) sont les mêmes en réel.",
        "whatToDo": [
          "Lire l’explication ci-dessus",
          "Dans le terminal, essayez **ls** ou **pwd** pour voir qu’ils se comportent comme un shell normal",
          "Tapez **next** quand vous êtes prêt à continuer"
        ]
      },
      "intro-2": {
        "title": "Ce qu’on a simplifié : la commande edit et la simulation Git",
        "description": "Quelques éléments de ce tutoriel sont **simplifiés ou spécifiques** pour que vous puissiez apprendre sans rien installer. **Modifier des fichiers :** Dans un vrai terminal vous ouvririez un éditeur de texte (**nano**, **vim**, ou le fichier dans une app). Ici nous utilisons une commande intégrée **edit** : tapez **edit nomfichier** (ex. **edit readme.txt**) dans le terminal et un **panneau d’édition s’ouvre en dessous**—modifiez le contenu et cliquez sur **Enregistrer**. C’est propre à ce tutoriel. **Git :** Nous simulons Git dans le navigateur. Les commandes **git init**, **git add**, **git commit**, **git status**, **git branch**, **git merge**, **git remote**, **git push** et **git pull** se comportent comme en vrai et enseignent le vrai workflow. Mais il n’y a pas de vrai réseau : **git push** et **git pull** ne parlent pas à de vrais serveurs—les dépôts distants et les clones sont simulés. Vous n'avez pas besoin de comprendre cela pour l'instant—nous verrons les dépôts distants et les clones dans les leçons suivantes. Donc : la navigation et les commandes fichiers sont proches du réel ; **edit** est propre au tutoriel ; la logique Git est réelle, mais les remotes sont simulés.",
        "whyImportant": "Savoir ce qui est « réel » ou « pour cette leçon » vous aide à savoir à quoi vous attendre quand vous utiliserez Git et un terminal sur votre machine. Vous utiliserez un vrai éditeur et un vrai GitHub ; les notions apprises ici resteront valables.",
        "whatToDo": [
          "Lire l’explication ci-dessus",
          "Quand une leçon vous demande d’éditer un fichier, rappelez-vous : tapez **edit** suivi du nom du fichier indiqué dans la leçon (ex. **edit readme.txt**) dans le terminal, puis utilisez l’éditeur en dessous et cliquez sur Enregistrer",
          "Tapez **next** quand vous êtes prêt à commencer les leçons sur le contrôle de version"
        ]
      },
      "vc-1": {
        "title": "Qu'est-ce que le contrôle de version ?",
        "description": "Le contrôle de version permet de sauvegarder et de suivre l'évolution de vos fichiers dans le temps. Au lieu d'accumuler des fichiers comme \"these_v1.docx\", \"these_finale.docx\" et \"these_VRAIMENT_finale.docx\", vous gardez un seul projet et un historique de chaque modification : qui a changé quoi, et quand. Vous pouvez revenir à n'importe quelle version antérieure si besoin.",
        "whyImportant": "Sans contrôle de version, il est facile de perdre du travail, d'écraser les changements d'un collègue ou d'oublier ce qu'on a modifié. Avec lui, vous avez un historique clair et pouvez collaborer en toute sécurité. Pour les projets en humanités numériques—éditions, corpus, jeux de données, sites web—c'est essentiel : on travaille souvent en équipe, on itère sur des années, et on doit pouvoir citer ou reproduire un état précis du projet.",
        "whatToDo": [
          "Lire l'explication ci-dessus",
          "Penser à un projet (ex. une édition de texte ou un jeu de données) où vous voudriez suivre chaque changement",
          "Dans le terminal à droite, taper **next** quand vous êtes prêt à continuer"
        ]
      },
      "vc-2": {
        "title": "Pourquoi le contrôle de version compte pour les humanités numériques",
        "description": "Les projets en humanités numériques mêlent souvent textes, métadonnées, code et plusieurs personnes. Le contrôle de version permet : d'avoir une seule source de vérité au lieu de copies éparpillées ; de voir qui a ajouté ou modifié quelle ligne ; de revenir en arrière en cas d'erreur ; et de permettre à d'autres (ou à vous plus tard) de comprendre et reproduire votre travail. Beaucoup de financeurs et d'éditeurs attendent ou recommandent désormais le contrôle de version pour la transparence et la reproductibilité.",
        "whyImportant": "Le travail en HN est de la recherche. Pouvoir montrer comment un corpus ou une édition a évolué, et restaurer ou citer une version donnée, sert à la fois la pratique savante et la science ouverte. Apprendre Git et GitHub est l'une des compétences les plus utiles à ajouter à votre boîte à outils HN.",
        "whatToDo": [
          "Lire pourquoi les projets HN bénéficient du contrôle de version",
          "Dans le terminal, taper **next** pour continuer"
        ]
      },
      "git-1": {
        "title": "Qu'est-ce que Git ?",
        "description": "Git est un outil gratuit et open source qui fait du contrôle de version sur votre ordinateur. Créé pour gérer le code source du noyau Linux, il est utilisé partout dans le monde. Git fonctionne en local : il conserve tout l'historique de votre projet dans un dossier caché (un dépôt) à l'intérieur du projet. Vous n'avez pas besoin d'internet pour faire des commits—seulement quand vous voulez partager ou sauvegarder sur un serveur comme GitHub. Dans ce cours nous simulons Git dans le terminal sur cette page—aucune installation requise.",
        "whyImportant": "Git est le standard du contrôle de version en logiciel et dans beaucoup de projets HN. Comprendre qu'il est « local d'abord » (votre historique est sur votre machine) aide à voir pourquoi on ajoute ensuite GitHub pour la sauvegarde et la collaboration.",
        "whatToDo": [
          "Dans le terminal à droite, taper : **git --version**",
          "Vous verrez une version simulée. (Sur un vrai ordinateur vous l'installeriez depuis https://git-scm.com/.)",
          "Taper **next** quand vous êtes prêt à continuer"
        ],
        "codeTemplate": "git --version"
      },
      "git-2": {
        "title": "Votre premier dépôt : git init",
        "description": "Un dépôt (repository) est le dossier où Git conserve l'historique du projet. Pour transformer un dossier en dépôt Git, on lance git init dans ce dossier. Ici, le terminal est déjà dans un dossier projet simulé (~/my-project). Après git init, Git suivra les changements des fichiers quand vous le lui demanderez.",
        "whyImportant": "Créer un dépôt est la première étape pour utiliser Git. Ensuite nous ajouterons des fichiers et ferons des commits dans ce dépôt—tout dans le terminal du navigateur.",
        "whatToDo": [
          "Dans le terminal, taper : **git init**",
          "Vous devriez voir « Initialized empty Git repository in .git/ »",
          "La leçon se valide automatiquement quand vous exécutez la commande"
        ],
        "codeTemplate": "git init"
      },
      "git-3": {
        "title": "Mise en stage et commit : git add et git commit",
        "description": "Git ne sauvegarde pas chaque changement automatiquement. Vous choisissez quels changements inclure dans un « commit » (une photo du projet). D'abord vous mettez les fichiers en stage avec git add, puis vous créez la photo avec git commit -m \"Votre message\". Vous pouvez créer ou modifier des fichiers ici : utilisez **echo \"texte\" > nomfichier** ou **edit nomfichier**. Pour modifier un fichier dans cette simulation : tapez **edit** suivi du nom du fichier dans le terminal ; l'éditeur s'ouvre en dessous—faites vos modifications et cliquez sur Enregistrer. Puis lancez git add et git commit dans le terminal.",
        "whyImportant": "Les commits sont les briques de votre historique. De bons messages de commit aident vous et les autres à comprendre le projet plus tard—surtout en HN quand il faut citer ou expliquer une version précise.",
        "whatToDo": [
          "Dans le terminal : créer ou modifier un fichier (ex. **echo \"Bonjour\" > readme.txt** ou **edit readme.txt** puis enregistrer). Pour modifier un fichier : tapez **edit nomfichier** dans le terminal ; l'éditeur s'ouvre en dessous—cliquez sur Enregistrer quand c'est fait.",
          "Puis taper : **git add .** (ou **git add readme.txt**)",
          "Puis : **git commit -m \"Premier commit\"** (un message court)",
          "La leçon se valide quand vous faites un commit"
        ],
        "codeTemplate": "git add .\ngit commit -m \"Votre message court\""
      },
      "git-4": {
        "title": "Vérifier l'état : git status",
        "description": "À tout moment vous pouvez lancer git status pour voir quels fichiers sont modifiés dans votre **arbre de travail**, lesquels sont des **changements en stage** (prêts pour le prochain commit), et lesquels ne sont pas suivis. Essayez de modifier un fichier (echo ou edit) et relancez git status pour voir le changement. Pour modifier un fichier ici : tapez **edit nomfichier** dans le terminal ; l'éditeur s'ouvre en dessous—puis cliquez sur Enregistrer.",
        "whyImportant": "Utiliser git status régulièrement évite de committer les mauvais fichiers ou d'oublier d'ajouter quelque chose. C'est une habitude qui vous servira dans les vrais projets.",
        "whatToDo": [
          "Dans le terminal, taper : **git status**",
          "Optionnel : modifier un fichier (**echo \"suite\" >> readme.txt** ou **edit readme.txt**) puis **git status** (pour éditer : tapez **edit readme.txt** dans le terminal ; l'éditeur s'ouvre en dessous—cliquez sur Enregistrer)",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git status"
      },
      "git-5": {
        "title": "Ignorer des fichiers : .gitignore",
        "description": "Certains fichiers ne doivent jamais être commités : secrets, sorties de build ou config locale. Un fichier **.gitignore** est une série de motifs (un par ligne). Git compare chaque motif au nom des fichiers : si un fichier correspond, Git l'ignore—il n'apparaît pas comme non suivi dans **git status** et ne sera pas ajouté avec **git add .**. Les motifs peuvent être littéraux (ex. **secret.txt** pour ce fichier précis) ou utiliser ** * ** comme joker pour « n'importe quels caractères ». Par exemple, ***.log** signifie « tout fichier dont le nom se termine par .log », donc **debug.log**, **server.log** et **error.log** seront tous ignorés. Un autre motif pratique est ***.env** pour ignorer les fichiers d'environnement qui contiennent souvent des secrets. Créez **.gitignore** avec **edit .gitignore** ; ajoutez vos motifs, puis cliquez sur Enregistrer. Créez un fichier qui correspond à l'un de vos motifs (ex. **echo \"x\" > secret.txt** ou **echo \"x\" > debug.log**) et lancez **git status**—le fichier correspondant n'apparaîtra pas. Commitez le fichier **.gitignore** lui-même pour partager les règles avec les autres. GitHub propose une collection de modèles .gitignore couramment utilisés : [github/gitignore](https://github.com/github/gitignore).",
        "whyImportant": "Sans .gitignore vous pourriez commiter des mots de passe, clés API ou des milliers de fichiers générés. En HN on ignore souvent les caches de données, la config locale et les sauvegardes d'éditeur.",
        "whatToDo": [
          "Créer un fichier **.gitignore** (ex. **edit .gitignore** et ajouter un motif : **secret.txt** pour ce fichier précis, ou ***.log** pour ignorer tout fichier se terminant par .log). Tapez **edit .gitignore** dans le terminal ; l'éditeur s'ouvre en dessous—ajoutez au moins un motif et cliquez sur Enregistrer.",
          "Optionnel : créer un fichier qui correspond (ex. **echo \"ne pas commiter\" > secret.txt**)",
          "Lancer **git status**—vous devriez voir **.gitignore** comme non suivi mais pas le fichier ignoré",
          "Lancer **git add .gitignore** et **git commit -m \"Add .gitignore\"** pour terminer la leçon"
        ],
        "codeTemplate": "edit .gitignore\n# ajouter la ligne : secret.txt\ngit add .gitignore\ngit commit -m \"Add .gitignore\""
      },
      "git-6": {
        "title": "Corriger les erreurs : unstage, annuler, amend",
        "description": "Vous pouvez corriger les erreurs courantes sans perdre votre travail. **git restore --staged <fichier>** retire un fichier du stage (l'enlève du prochain commit). **git restore <fichier>** annule les changements non commités dans ce fichier dans votre **arbre de travail**—il le ramène à la dernière version commitée (à utiliser avec précaution). **git commit --amend -m \"Nouveau message\"** remplace le dernier commit : soit pour changer le message, soit pour y intégrer des **changements en stage** dans ce commit. Ici vous avez un commit ; essayez de retirer un fichier du stage, d'annuler des changements, ou d'amender le dernier commit.",
        "whyImportant": "Tout le monde met en stage le mauvais fichier ou commite avec une typo. Savoir unstage, annuler ou amender garde l'historique propre et évite les push embarrassants.",
        "whatToDo": [
          "**Retirer du stage :** Modifiez **readme.txt** (tapez **edit readme.txt** dans le terminal ; l'éditeur s'ouvre en dessous—éditez et cliquez sur Enregistrer), lancez **git add readme.txt**, puis **git restore --staged readme.txt**. Lancez **git status** pour voir qu'il n'est plus en stage.",
          "**Annuler les changements :** Modifiez **readme.txt** à nouveau (**edit readme.txt** dans le terminal, puis Enregistrer), puis **git restore readme.txt**. Le fichier revient à la dernière version commitée.",
          "**Amender :** Faites un petit changement, **git add** et **git commit -m \"Typo\"**, puis **git commit --amend -m \"Fixed typo\"** pour remplacer le message du dernier commit.",
          "Taper **next** quand vous avez essayé au moins une de ces commandes"
        ],
        "codeTemplate": "git add readme.txt\ngit restore --staged readme.txt\ngit status"
      },
      "branch-1": {
        "title": "Branches : créer et changer de branche",
        "description": "Les branches permettent de travailler sur une ligne de développement séparée sans toucher à la branche principale. Chaque branche peut avoir sa propre version des fichiers. Utilisez **git branch** pour lister les branches (la courante a un *). Créez une branche avec **git checkout -b <nom>** (création et bascule). Utilisez **git checkout <nom>** pour passer à une branche existante—le répertoire de travail est mis à jour pour refléter les fichiers de cette branche. Dans cette leçon vous modifierez **readme.txt** différemment sur chaque branche, puis **cat readme.txt** pour constater que le contenu du fichier est différent sur chaque branche.",
        "whyImportant": "Les branches sont essentielles pour tester des changements, travailler sur des fonctionnalités à part et collaborer. En HN vous pouvez avoir une branche pour une variante d'édition ou une mise à jour de jeu de données.",
        "whatToDo": [
          "Lancer **git branch** pour voir la branche courante (main)",
          "Créer une branche : **git checkout -b feature** (ou un autre nom)",
          "Modifier **readme.txt** sur cette branche (ex. **echo \"Version feature\" > readme.txt** ou **edit readme.txt**). Pour éditer : tapez **edit readme.txt** dans le terminal ; l'éditeur s'ouvre en dessous—cliquez sur Enregistrer. Puis **git add readme.txt** et **git commit -m \"Contenu feature\"**",
          "Revenir sur main : **git checkout main**. Lancer **cat readme.txt** pour voir la version du fichier sur main",
          "Modifier **readme.txt** sur main avec un contenu différent (ex. **echo \"Version main\" > readme.txt** ou **edit readme.txt**—tapez **edit readme.txt** dans le terminal, éditez dans le panneau ci-dessous, puis Enregistrer). Puis **git add readme.txt** et **git commit -m \"Contenu main\"**",
          "Relancer **cat readme.txt**—vous verrez la version main. Puis **git checkout feature** et **cat readme.txt**—vous verrez la version feature. Chaque branche a sa propre copie.",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout -b feature\necho \"Version feature\" > readme.txt\ngit add readme.txt\ngit commit -m \"Contenu feature\"\ngit checkout main\ncat readme.txt"
      },
      "branch-2": {
        "title": "Fusionner des branches",
        "description": "Quand le travail sur une branche vous convient, vous la fusionnez dans une autre (souvent main) avec **git merge <branche>**. Git combine les historiques. Si l'autre branche a de nouveaux commits depuis la divergence, vous pouvez avoir un commit de merge ; sinon, Git fait un « fast-forward » (pas de commit de merge). Après la fusion, la branche courante contient les commits de l'autre. Une fois une branche fusionnée, vous pouvez la supprimer en local avec **git branch -d <nom>** pour garder la liste des branches lisible ; les commits restent dans l'historique de la branche dans laquelle vous avez fusionné.",
        "whyImportant": "La fusion permet de réintégrer le travail d'une branche dans la ligne principale. Comprendre merge vs. fast-forward aide à garder un historique clair. Supprimer les branches fusionnées évite l'encombrement et rend clair quelles branches sont encore en cours.",
        "whatToDo": [
          "Créer une branche et faire un commit (ex. **git checkout -b feature**, modifier un fichier—tapez **edit readme.txt** dans le terminal, modifiez le contenu dans l'éditeur ci-dessous et cliquez sur Enregistrer—puis **git add .**, **git commit -m \"Ajout feature\"**)",
          "Revenir sur main : **git checkout main**",
          "Fusionner : **git merge feature**",
          "Optionnel : supprimer la branche fusionnée : **git branch -d feature** (pour garder la liste des branches lisible)",
          "Lancer **git log** pour voir l'historique fusionné. Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout -b feature\necho \"Contenu feature\" > readme.txt\ngit add readme.txt\ngit commit -m \"Ajout feature\"\ngit checkout main\ngit merge feature\ngit branch -d feature"
      },
      "branch-3": {
        "title": "Fusion squash",
        "description": "Une **fusion squash** (**git merge --squash <branche>**) apporte les changements de l'autre branche dans votre **arbre de travail** comme un seul ensemble de **changements en stage**, sans créer de commit de merge. Vous commitez ensuite une fois—plusieurs commits sur l'autre branche deviennent un seul commit sur la branche courante. Utile pour garder un historique propre.",
        "whyImportant": "Squasher transforme une série de commits « WIP » ou « typo » en un commit clair, plus facile à relire et citer.",
        "whatToDo": [
          "Vous débutez sur une branche (**feature**) qui a déjà plusieurs commits. Revenir sur main : **git checkout main**",
          "Lancer **git merge --squash feature**",
          "Lancer **git status**—vous verrez les changements en stage. Puis **git commit -m \"Feature squashed\"** pour terminer",
          "*(Optionnel)* Supprimer la branche maintenant qu'elle est fusionnée : **git branch -d feature**",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout main\ngit merge --squash feature\ngit commit -m \"Feature squashed\"\ngit branch -d feature"
      },
      "branch-4": {
        "title": "Rebase",
        "description": "**git rebase <branche>** déplace les commits de la branche courante pour qu'ils reposent sur l'autre branche. Le résultat est un historique linéaire : d'abord les commits de l'autre branche, puis les vôtres rejoués. Utilisez-le pour mettre à jour une branche feature avec le dernier main, ou pour nettoyer l'historique avant une fusion.",
        "whyImportant": "Le rebase garde un historique linéaire et évite les commits de merge inutiles. En HN cela peut rendre l'évolution d'un texte ou d'un jeu de données plus lisible.",
        "whatToDo": [
          "Vous êtes sur la branche **feature** qui a divergé d'un ancien **main**. Main a avancé avec de nouveaux commits ; votre feature a un commit au-dessus de l'ancien main.",
          "Lancez **git rebase main** pour rejouer votre commit feature sur le main actuel.",
          "Les commits de votre branche sont maintenant au-dessus de main. Utilisez **git log --oneline** pour voir l'historique linéaire.",
          "Vous pouvez continuer à travailler sur votre branche feature et faire un **git rebase main** régulièrement pour rester à jour.",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git rebase main\ngit log --oneline"
      },
      "branch-5": {
        "title": "Conflits de fusion",
        "description": "Quand deux branches modifient la **même partie** du même fichier, Git ne peut pas fusionner automatiquement. Vous obtenez un **conflit de fusion** : le fichier est marqué avec des marqueurs de conflit (**<<<<<<<**, **=======**, **>>>>>>>**) qui montrent les deux versions. Pour le résoudre : ouvrez le fichier, décidez du contenu final (garder une version, combiner les deux, ou modifier à la main), puis supprimez les marqueurs de conflit, les lignes **HEAD** et le nom de branche (ex. **feature**), et le contenu de la version que vous ne voulez pas—en ne gardant que le texte final souhaité. Puis **git add** le fichier et **git commit** pour terminer la fusion. Dans cette simulation, pour ouvrir un fichier : tapez **edit nomfichier** dans le terminal ; l'éditeur s'ouvre en dessous—modifiez le contenu et cliquez sur Enregistrer. Les conflits sont normaux quand plusieurs personnes modifient les mêmes lignes ; les résoudre fait partie du travail en équipe.",
        "whyImportant": "En HN, plusieurs éditeurs ou jeux de données peuvent toucher les mêmes fichiers. Savoir lire les marqueurs de conflit et résoudre les conflits permet de fusionner des branches et d'intégrer le travail des autres en toute sérénité.",
        "whatToDo": [
          "**readme.txt** contient déjà un conflit. Tapez **cat readme.txt** pour voir les marqueurs de conflit",
          "Tapez **edit readme.txt** dans le terminal—l'éditeur s'ouvre en dessous. Supprimez les marqueurs de conflit (<<<<<<<, =======, >>>>>>>), les lignes **HEAD** et **feature** (branche), et le contenu de la version que vous ne voulez pas. Gardez uniquement le contenu final souhaité (une version, l'autre, ou une combinaison). Cliquez sur **Enregistrer**",
          "Indexez le fichier résolu : **git add readme.txt**",
          "Terminez la fusion : **git commit -m \"Résoudre le conflit\"**",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "cat readme.txt\nedit readme.txt\ngit add readme.txt\ngit commit -m \"Résoudre le conflit\""
      },
      "gh-1": {
        "title": "Qu'est-ce que GitHub ?",
        "description": "GitHub est un site qui héberge des dépôts Git dans le cloud. Il vous donne une sauvegarde de votre dépôt, un historique visible en ligne, et des outils pour collaborer : d'autres peuvent cloner votre dépôt, proposer des changements (pull requests), et vous pouvez gérer les issues et la documentation. GitHub est très répandu dans l'open source et en HN.",
        "whyImportant": "Git est local ; GitHub est distant. Ensemble ils permettent de sauvegarder votre travail, de le partager et de collaborer. Beaucoup de projets HN publient leurs données et leur code sur GitHub pour la transparence et la réutilisation.",
        "whatToDo": [
          "Lire la section ci-dessus. (Vous pourrez créer un compte sur https://github.com plus tard depuis votre ordinateur.)",
          "Dans le terminal, taper **next** quand vous êtes prêt à continuer"
        ]
      },
      "gh-2": {
        "title": "Créer un dépôt sur GitHub",
        "description": "Sur GitHub, vous cliqueriez sur « New repository », choisiriez un nom (ex. mon-projet-hn) et obtiendriez une URL pour connecter votre dépôt local. Dans un vrai workflow on crée ce dépôt d'abord, puis on utilise son URL dans git remote et git push. Vous pourrez essayer sur github.com plus tard ; pour cette leçon on se concentre sur l'idée.",
        "whyImportant": "Le dépôt distant sur GitHub est l'endroit où votre historique local sera copié quand vous ferez un push. Le créer d'abord vous donne l'URL nécessaire pour l'étape suivante.",
        "whatToDo": [
          "Lire les étapes ci-dessus (vous pourrez créer un vrai dépôt sur GitHub plus tard depuis votre ordinateur)",
          "Dans le terminal, taper **next** quand c'est fait"
        ]
      },
      "gh-3": {
        "title": "Pousser votre code : git remote et git push",
        "description": "Pour envoyer vos commits locaux sur GitHub, vous liez votre dépôt au distant avec git remote add origin <URL>, puis vous poussez avec git push -u origin main. Ici vous pouvez exécuter ces commandes dans le terminal (une URL quelconque suffit pour la simulation) ; la leçon se valide quand vous exécutez git remote add ou git push.",
        "whyImportant": "Pousser (push) est la façon de sauvegarder et partager votre travail. Une fois configuré, ça devient une étape simple de votre routine.",
        "whatToDo": [
          "Dans le terminal : **git remote add origin https://github.com/you/repo.git** (n'importe quelle URL pour cette simulation). Vous ne configurez le distant qu'une seule fois ; la prochaine fois que vous pousserez, ce sera vers origin.",
          "Puis : **git push -u origin main**",
          "La leçon se valide quand vous exécutez les commandes"
        ],
        "codeTemplate": "git remote add origin https://github.com/USER/REPO.git\ngit push -u origin main"
      },
      "gh-4": {
        "title": "Obtenir une copie : git clone et git pull",
        "description": "Pour obtenir une copie complète du dépôt de quelqu'un (ou du vôtre depuis un autre ordinateur), on utilise git clone <URL>. Quand vous clonez, Git crée un nouveau dossier (généralement nommé d'après le dépôt) et y place la copie complète—le dépôt cloné se trouve donc toujours dans son propre répertoire. Après avoir cloné, faites **cd** dans ce nouveau dossier (ex. **cd repo**) pour travailler dans le projet. Pour mettre à jour une copie existante, on lance git pull. Ici vous pouvez essayer ces commandes dans le terminal—ex. **git clone https://github.com/some/repo** ou **git pull**—pour voir la sortie simulée.",
        "whyImportant": "Clone et pull sont la façon de travailler avec des projets HN existants, de contribuer au travail d'autres, ou de synchroniser entre machines. Ils sont essentiels pour la collaboration.",
        "whatToDo": [
          "Dans le terminal, essayer **git clone https://github.com/some/repo** ou **git pull**",
          "Après avoir cloné, faire **cd** dans le dossier du dépôt (ex. **cd repo**) pour être dans le projet",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git clone https://github.com/USER/REPO.git\ncd REPO\ngit pull"
      },
      "collab-1": {
        "title": "Collaboration et bonnes pratiques pour la HN",
        "description": "En pratique, les équipes HN utilisent des branches (lignes de travail séparées) et des pull requests (changements proposés pour revue) sur GitHub. Committez souvent avec des messages clairs ; poussez régulièrement pour sauvegarder. Utilisez un README pour expliquer le projet et, si pertinent, une licence pour que les autres sachent comment réutiliser vos données et votre code. Ces pratiques rendent votre projet compréhensible et citable.",
        "whyImportant": "De bonnes habitudes de contrôle de version rendent les projets HN reproductibles, transparents et plus faciles à transmettre ou publier. Elles s'alignent avec la science ouverte et les attentes des financeurs.",
        "whatToDo": [
          "Lire les conseils de collaboration et de bonnes pratiques ci-dessus",
          "Dans le terminal, taper **next** pour continuer"
        ]
      },
      "collab-2": {
        "title": "Conventional commits",
        "description": "Les **Conventional Commits** sont une convention simple pour rédiger des messages de commit clairs et cohérents. La forme est : **type(scope): description**. Types courants : **feat** (nouvelle fonctionnalité), **fix** (correction de bug), **docs** (documentation), **style** (formatage), **refactor** (changement de code sans correction ni nouvelle fonctionnalité), **test** (tests), **chore** (maintenance). Exemples : **feat(parser): add support for CSV** ou **fix: correct spelling in README**. Cela rend l'historique plus lisible et permet à des outils de générer des changelogs ou des versions automatiquement. En savoir plus : https://www.conventionalcommits.org/en/v1.0.0/",
        "whyImportant": "Des messages de commit structurés aident les équipes (et vous plus tard) à comprendre ce qui a changé et pourquoi. Ils s'alignent sur le versioning sémantique et sont très utilisés en open source et en HN.",
        "whatToDo": [
          "Lire la section sur les conventional commits ci-dessus",
          "Consulter [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) pour la spécification complète",
          "Taper **next** pour continuer"
        ]
      },
      "collab-3": {
        "title": "Prochaines étapes : installer Git, GitHub et l'authentification",
        "description": "Ce tutoriel s'exécute dans le navigateur. Pour utiliser Git et GitHub sur votre ordinateur : (1) **Installer Git** depuis https://git-scm.com/ (ou votre gestionnaire de paquets). (2) **Créer un compte GitHub** sur https://github.com si vous n'en avez pas. (3) **Configurer l'authentification** pour pouvoir pousser et tirer : soit des **clés SSH** (recommandé), soit un **jeton d'accès personnel** en HTTPS. La doc GitHub explique les deux : « Connecting to GitHub with SSH » et « Managing your personal access tokens ». Une fois Git installé et l'authentification configurée, vous pourrez cloner des dépôts, pousser votre travail et ouvrir des pull requests en ligne de commande ou avec une interface graphique.",
        "whyImportant": "Sans ces étapes, des commandes comme git push demanderont des identifiants ou échoueront. Quelques minutes de configuration sur votre machine débloquent tout ce que vous avez appris ici.",
        "whatToDo": [
          "Lire les étapes ci-dessus et mettre les liens en favoris",
          "Quand vous êtes prêt, taper **next** pour terminer le cours et voir votre certificat"
        ]
      }
    },
    "glossary": {
      "version control": "Système qui enregistre les changements des fichiers dans le temps pour pouvoir retrouver ou comparer des versions précises.",
      "repository": "Dossier géré par Git, contenant les fichiers du projet et tout l'historique des commits.",
      "dépôt": "Dossier géré par Git, contenant les fichiers du projet et tout l'historique des commits.",
      "repositories": "Dossiers gérés par Git, contenant les fichiers du projet et tout l'historique des commits. GitHub héberge des dépôts Git dans le cloud.",
      "dépôts": "Dossiers gérés par Git, contenant les fichiers du projet et tout l'historique des commits. GitHub héberge des dépôts Git dans le cloud.",
      "repo": "Abréviation de dépôt (repository) : le dossier où Git conserve l'historique du projet.",
      "commit": "Photo du projet à un instant donné, avec un message et un identifiant unique. Les commits forment l'historique du projet.",
      "stage": "Marquer des fichiers comme prêts à être inclus dans le prochain commit (avec git add).",
      "staged": "Marqué comme prêt à être inclus dans le prochain commit (avec git add).",
      "staged changes": "Changements que vous avez ajoutés avec git add et qui seront inclus dans le prochain commit. git status les affiche sous « Changes to be committed ».",
      "changements en stage": "Changements que vous avez ajoutés avec git add et qui seront inclus dans le prochain commit. git status les affiche sous « Changes to be committed ».",
      "push": "Envoyer vos commits locaux vers un dépôt distant (ex. sur GitHub).",
      "pull": "Récupérer et fusionner les changements d'un dépôt distant dans votre branche actuelle.",
      "clone": "Télécharger une copie d'un dépôt (avec son historique) depuis un serveur distant.",
      "clones": "Copies d'un dépôt (avec tout son historique) téléchargées depuis un serveur distant. On peut cloner une fois par machine ou par copie de travail.",
      "remote": "Version du dépôt hébergée ailleurs (ex. sur GitHub), souvent nommée origin.",
      "distant": "Version du dépôt hébergée ailleurs (ex. sur GitHub), souvent nommée origin. Git est local ; GitHub est distant.",
      "remotes": "Versions du dépôt hébergées ailleurs (ex. sur GitHub). Un dépôt peut avoir plusieurs remotes ; le défaut est souvent origin.",
      "origin": "Nom par défaut du dépôt distant (souvent sur GitHub) auquel votre dépôt local est relié.",
      "Git": "Outil gratuit et open source pour le contrôle de version sur votre ordinateur. Il conserve tout l'historique du projet dans un dépôt et fonctionne en local ; l'internet n'est nécessaire que pour partager ou sauvegarder (ex. via GitHub).",
      "GitHub": "Plateforme web qui héberge des dépôts Git et propose des outils de collaboration, issues et documentation.",
      "Digital Humanities": "Recherche et enseignement qui combinent méthodes numériques et disciplines des humanités ; implique souvent textes, jeux de données et code qui bénéficient du contrôle de version.",
      "DH": "Abréviation pour humanités numériques (Digital Humanities).",
      "HN": "Abréviation pour humanités numériques (Digital Humanities).",
      "branch": "Ligne de développement séparée dans un dépôt Git. On crée des branches pour tester des changements ou travailler sur des fonctionnalités sans toucher à la ligne principale.",
      "branches": "Lignes de développement séparées dans un dépôt Git. On crée des branches pour tester des changements ou travailler sur des fonctionnalités sans toucher à la ligne principale.",
      "merge": "Fusionner les commits d'une autre branche dans la branche courante (ex. git merge feature).",
      "merge conflict": "Quand deux branches modifient la même partie du même fichier, Git ne peut pas fusionner automatiquement. Le fichier est marqué avec des marqueurs de conflit (<<<<<<<, =======, >>>>>>>) et les lignes HEAD/nom de branche ; vous éditez le fichier pour choisir le contenu final, supprimez les marqueurs et le contenu de la branche non souhaitée, puis git add et git commit pour terminer la fusion.",
      "merge commit": "Commit qui enregistre la fusion de deux branches lorsqu'elles ont divergé (pas de fast-forward).",
      "fast-forward": "Lors d'une fusion, si la branche courante n'a pas divergé, Git avance simplement le pointeur ; aucun commit de merge n'est créé.",
      "squash merge": "Fusion qui apporte les changements d'une autre branche en un seul ensemble de changements en stage, sans commit de merge. On committe ensuite une fois, donc plusieurs commits en deviennent un.",
      "rebase": "Déplacer les commits de votre branche pour qu'ils reposent sur une autre branche, pour un historique linéaire. Commande : git rebase <branche>.",
      "pull request": "Sur GitHub, proposition de fusionner les changements d'une branche dans une autre, pour revue et discussion avant la fusion.",
      "pull requests": "Sur GitHub, propositions de fusionner les changements d'une branche dans une autre, pour revue et discussion avant la fusion.",
      "collaboration": "Travailler avec d'autres sur le même projet. GitHub propose des outils pour collaborer : cloner le dépôt, ouvrir des pull requests, discuter dans les issues.",
      "collaborer": "Travailler avec d'autres sur le même projet (ex. partager un dépôt sur GitHub, relire des pull requests, discuter dans les issues).",
      "documentation": "Explication écrite d'un projet : à quoi il sert, comment l'utiliser, comment contribuer. Sur GitHub, les README et les wikis constituent la documentation.",
      "cloud": "Services et stockage sur internet plutôt que sur votre ordinateur. GitHub héberge des dépôts Git dans le cloud pour sauvegarder et partager.",
      "README": "Fichier (souvent README.md) qui explique un projet : de quoi il s'agit, comment l'utiliser et contribuer. Souvent affiché sur GitHub.",
      "untracked": "Fichier que Git ne suit pas encore (pas dans la dernière photo ni en stage). git status les affiche.",
      ".gitignore": "Fichier à la racine du dépôt qui liste des motifs (un par ligne). Git ignore les fichiers correspondants : ils n'apparaissent pas comme non suivis et ne sont pas ajoutés avec git add .",
      "secrets": "Données sensibles (mots de passe, clés API, jetons) qui ne doivent pas être commitées. Listez-les dans .gitignore pour qu'elles ne soient jamais ajoutées.",
      "API keys": "Identifiants qui permettent à un logiciel d'accéder à une API ou un service externe. Ils doivent rester privés et ne jamais être commités ; ajoutez des motifs dans .gitignore.",
      "tokens": "En authentification, identifiant (ex. jeton d'accès personnel ou jeton de session) utilisé pour prouver son identité. Les jetons doivent rester privés et ne jamais être commités ; listez-les dans .gitignore.",
      "passwords": "Chaînes secrètes utilisées pour authentifier un utilisateur ou un service. Ne commitez jamais de mots de passe ; utilisez .gitignore pour exclure les fichiers qui en contiennent.",
      "clés API": "Identifiants qui permettent à un logiciel d'accéder à une API ou un service externe. Ils doivent rester privés et ne jamais être commités ; ajoutez des motifs dans .gitignore.",
      "jetons": "En authentification, identifiant (ex. jeton d'accès personnel ou jeton de session) utilisé pour prouver son identité. Les jetons doivent rester privés et ne jamais être commités ; listez-les dans .gitignore.",
      "mots de passe": "Chaînes secrètes utilisées pour authentifier un utilisateur ou un service. Ne commitez jamais de mots de passe ; utilisez .gitignore pour exclure les fichiers qui en contiennent.",
      "build outputs": "Fichiers générés par une étape de build ou de compilation (ex. code compilé, assets). Ils peuvent être recréés à partir des sources et ne doivent pas être commités ; listez-les dans .gitignore.",
      "local config": "Fichiers de configuration spécifiques à votre machine ou à votre environnement (ex. chemins locaux, paramètres de debug). Souvent listés dans .gitignore pour que chaque développeur garde sa propre copie en local.",
      "amend": "Modifier le dernier commit. git commit --amend -m \"Nouveau message\" remplace le message ; avec des changements en stage, les intègre dans ce commit.",
      "snapshot": "Copie du projet à un instant donné. Dans Git, chaque commit est une photo (snapshot) des fichiers suivis.",
      "main": "Nom par défaut de la branche principale dans beaucoup de dépôts Git. Les branches de fonctionnalités sont souvent fusionnées dans main.",
      "working tree": "Répertoire contenant les fichiers de votre projet tels qu'ils apparaissent sur le disque. Vos modifications sont dans l'arbre de travail jusqu'à ce que vous les mettiez en stage et committiez.",
      "conflict markers": "Les symboles que Git insère dans un fichier lors d'un conflit de fusion : <<<<<<<, =======, >>>>>>>. On les supprime en résolvant le conflit.",
      "checkout": "Passer sur une autre branche (ex. git checkout main) ou restaurer un fichier. git checkout -b <nom> crée et bascule sur une nouvelle branche.",
      "upstream": "La branche distante que votre branche courante suit. La définir (ex. avec git push -u origin main) relie votre branche au distant.",
      "license": "Fichier ou notice qui indique comment les autres peuvent utiliser, partager ou modifier le code et les données du projet.",
      "modified": "Fichier qui a été modifié depuis le dernier commit. git status les affiche (et indique s'ils sont en stage ou non).",
      "unstage": "Retirer un fichier du stage pour qu'il ne soit pas inclus dans le prochain commit (ex. git restore --staged <fichier>).",
      "open source": "Logiciel ou projet dont le code source (ou les données) est mis à disposition pour utilisation, modification et partage, souvent sous une licence.",
      "issues": "Sur GitHub, moyen de suivre les tâches, bugs et discussions d'un dépôt. Les autres peuvent ouvrir des issues pour proposer des changements ou signaler des problèmes.",
      "authentication": "Le processus pour prouver votre identité à GitHub afin de pousser et tirer. Méthodes courantes : clés SSH (recommandé) ou jeton d'accès personnel en HTTPS.",
      "SSH keys": "Moyen sécurisé de s'authentifier auprès de GitHub sans taper de mot de passe à chaque fois. Vous générez une paire de clés sur votre ordinateur et ajoutez la clé publique à votre compte GitHub.",
      "personal access token": "Identifiant de type mot de passe pour HTTPS qui permet de pousser et tirer depuis GitHub. Vous le créez dans les paramètres GitHub et l'utilisez à la place du mot de passe du compte.",
      "staging area": "L'endroit où Git garde les fichiers que vous avez ajoutés avec git add, prêts pour le prochain commit. Aussi appelé l'index. git status affiche ce qui est en stage.",
      "history": "La séquence des commits dans un dépôt. git log affiche l'historique ; chaque commit pointe vers son (ses) parent(s).",
      "historique": "La séquence des commits dans un dépôt. git log affiche l'historique ; chaque commit pointe vers son (ses) parent(s).",
      "local": "Sur votre propre ordinateur. Un dépôt local est la copie sur votre machine ; les commits locaux ne sont pas encore poussés vers un distant.",
      "tracked": "Fichier que Git suit—il était dans le dernier commit ou a été ajouté avec git add. Les fichiers non suivis ne sont pas encore dans le dépôt.",
      "commit message": "La courte description que vous donnez en committant (ex. avec -m \"Votre message\"). De bons messages aident à comprendre l'historique plus tard.",
      "workflow": "La façon dont vous utilisez Git au quotidien : modifier des fichiers, git add, git commit, et (pour partager) git push ou git pull.",
      "resolve": "Résoudre un conflit de fusion en éditant le fichier, en choisissant le contenu final, en supprimant les marqueurs de conflit et les lignes HEAD/branche et la version non souhaitée, puis en mettant en stage et en committant.",
      "reproducibility": "Capacité pour d'autres (ou vous plus tard) de recréer ou citer un état précis d'un projet. Le contrôle de version favorise la reproductibilité.",
      "transparency": "Rendre l'historique des changements visible et traçable. Les financeurs et éditeurs attendent souvent le contrôle de version pour la transparence.",
      ".git": "Le dossier caché à l'intérieur de votre projet où Git stocke le dépôt (tous les commits, branches et métadonnées). Créé par git init.",
      "feature branch": "Branche utilisée pour développer une seule fonctionnalité ou modification, souvent fusionnée dans main une fois terminée. Garde main stable.",
      "diverged": "Quand deux branches ont des commits différents—ex. vous avez commité sur main pendant qu'un autre a commité sur une autre branche. La fusion peut créer un commit de merge.",
      "discard": "Annuler les changements non commités dans un fichier (ex. git restore <fichier>). Le fichier revient à la dernière version commitée. À utiliser avec précaution.",
      "linear history": "Historique où les commits suivent une seule ligne, sans commits de merge. Le rebase peut produire un historique linéaire.",
      "humanités numériques": "Recherche et enseignement qui combinent méthodes numériques et disciplines des humanités ; implique souvent textes, jeux de données et code qui bénéficient du contrôle de version.",
      "conflit de fusion": "Quand deux branches modifient la même partie du même fichier, Git ne peut pas fusionner automatiquement. Le fichier est marqué avec des marqueurs de conflit (<<<<<<<, =======, >>>>>>>) ; vous éditez le fichier pour choisir le contenu final, supprimez les marqueurs, puis git add et git commit pour terminer la fusion.",
      "marqueurs de conflit": "Les symboles que Git insère dans un fichier lors d'un conflit de fusion : <<<<<<<, =======, >>>>>>>. On les supprime en résolvant le conflit.",
      "arbre de travail": "Répertoire contenant les fichiers de votre projet tels qu'ils apparaissent sur le disque. Vos modifications sont dans l'arbre de travail jusqu'à ce que vous les mettiez en stage et committiez.",
      "branche principale": "Nom par défaut de la branche principale dans beaucoup de dépôts Git (souvent main). Les branches de fonctionnalités sont souvent fusionnées dans la branche principale.",
      "clés SSH": "Moyen sécurisé de s'authentifier auprès de GitHub sans taper de mot de passe à chaque fois. Vous générez une paire de clés sur votre ordinateur et ajoutez la clé publique à votre compte GitHub.",
      "jeton d'accès personnel": "Identifiant de type mot de passe pour HTTPS qui permet de pousser et tirer depuis GitHub. Vous le créez dans les paramètres GitHub et l'utilisez à la place du mot de passe du compte.",
      "historique": "La séquence des commits dans un dépôt. git log affiche l'historique ; chaque commit pointe vers son (ses) parent(s).",
      "reproductibilité": "Capacité pour d'autres (ou vous plus tard) de recréer ou citer un état précis d'un projet. Le contrôle de version favorise la reproductibilité.",
      "transparence": "Rendre l'historique des changements visible et traçable. Les financeurs et éditeurs attendent souvent le contrôle de version pour la transparence.",
      "résoudre": "Résoudre un conflit de fusion en éditant le fichier, en choisissant le contenu final, en supprimant les marqueurs de conflit, puis en mettant en stage et en committant.",
      "branche de fonctionnalité": "Branche utilisée pour développer une seule fonctionnalité ou modification, souvent fusionnée dans main une fois terminée. Garde main stable.",
      "historique linéaire": "Historique où les commits suivent une seule ligne, sans commits de merge. Le rebase peut produire un historique linéaire.",
      "annuler": "Annuler les changements non commités dans un fichier (ex. git restore <fichier>). Le fichier revient à la dernière version commitée. À utiliser avec précaution.",
      "science ouverte": "Pratique qui consiste à rendre la recherche, les données et le code ouverts et réutilisables. Un bon contrôle de version et une documentation (ex. README, licence) favorisent la science ouverte.",
      "citable": "Que l'on peut citer ; un projet avec un historique clair, un README et une licence est plus facile à citer et à créditer.",
      "reproductible": "Que l'on peut recréer ou répéter ; le contrôle de version aide à rendre les projets HN reproductibles en conservant un historique clair des changements.",
      "transparent": "Rendre l'historique des changements visible et traçable ; le contrôle de version assure la transparence pour les financeurs et les collaborateurs.",
      "licence": "Fichier ou notice qui indique comment les autres peuvent utiliser, partager ou modifier le code et les données du projet.",
      "HTTPS": "Hypertext Transfer Protocol Secure ; protocole chiffré pour le web et Git. GitHub prend en charge HTTPS pour clone, push et pull ; on s'authentifie avec un jeton d'accès personnel.",
      "repos": "Abréviation de dépôts (repositories) : les dossiers de projet que l'on clone, pousse ou tire.",
      "command line": "Interface en texte où l'on tape des commandes (ex. git push, git clone). Aussi appelée terminal ou shell.",
      "ligne de commande": "Interface en texte où l'on tape des commandes (ex. git push, git clone). Aussi appelée terminal ou shell.",
      "GUI": "Interface graphique ; programme avec fenêtres, boutons et menus. Les logiciels Git en GUI (ex. GitHub Desktop, GitKraken) permettent de cloner, committer et pousser sans taper de commandes.",
      "interface graphique": "Programme avec fenêtres, boutons et menus (GUI). Les logiciels Git en interface graphique permettent de cloner, committer et pousser sans ligne de commande.",
      "@mention": "Notifier une personne sur GitHub en utilisant @ devant son nom d'utilisateur. Les utilisateurs dans une organisation sur GitHub peuvent également faire partie d'une équipe qui peut être mentionnée.",
      "access token": "Jeton utilisé à la place d'un mot de passe lors de l'exécution d'opérations Git sur HTTPS avec Git sur la ligne de commande ou l'API. Également appelé un personal access token.",
      "API preview": "Préversion d'API : manière d'essayer de nouvelles API et les modifications apportées aux méthodes d'API existantes avant qu'elles ne soient intégrées à l'API officielle GitHub.",
      "appliance": "Application logicielle combinée avec un système d'exploitation JeOS (Just Enough Operating System) pour s'exécuter de manière optimale sur du matériel de norme industrielle ou dans une machine virtuelle.",
      "assignee": "Utilisateur affecté à un problème.",
      "authentication code": "Code que vous fournirez, en plus de votre mot de passe GitHub, lors de la signature avec 2FA via le navigateur. Également appelé « code d'authentification 2FA ».",
      "base branch": "Branche de base : branche dans laquelle les modifications sont combinées lorsque vous fusionnez une demande de tirage.",
      "basic authentication": "Méthode d'authentification dans laquelle les informations d'identification sont envoyées sous forme de texte non chiffré.",
      "billing cycle": "Cycle de facturation : intervalle de temps appliqué à votre plan de facturation spécifique.",
      "billing email": "Adresse e-mail d'organisation à laquelle GitHub envoie les reçus, les frais de carte bancaire ou PayPal, et autres communications en rapport avec la facturation.",
      "billing manager": "Responsable de la facturation : membre de l'organisation qui gère les paramètres de facturation pour une organisation.",
      "billing plan": "Profil de facturation : plans de paiement pour les utilisateurs et les organisations qui comprennent des fonctionnalités fixes pour chaque type de plan.",
      "bio": "Description générée par l'utilisateur trouvée sur un profil.",
      "blame": "La fonctionnalité « blame » dans Git décrit la dernière modification de chaque ligne d'un fichier, qui montre généralement la révision, l'auteur et l'heure.",
      "block": "Retirer à un utilisateur la capacité à collaborer aux dépôts d'une organisation.",
      "branch restriction": "Restriction de branche : restriction que des administrateurs de dépôt peuvent activer afin que seuls certains utilisateurs puissent pousser ou apporter certaines modifications à la branche.",
      "Business plan": "Plan d'entreprise : plan de facturation d'organisation où vous pouvez collaborer sur des dépôts publics ou privés illimités, autoriser ou exiger l'authentification unique SAML, et provisionner l'accès avec SAML ou SCIM.",
      "CA certificate": "Certificat d'autorité de certification : certificat numérique délivré par une autorité de certification, qui garantit qu'il existe des connexions valides entre deux machines et qui vérifie la propriété d'un site.",
      "card": "Carte : carré déplaçable au sein d'un tableau de projet associé à un problème ou à une demande de tirage.",
      "check": "Un contrôle est un type de contrôle d'état sur GitHub. Voir Contrôles d'état.",
      "cherry-picking": "Choisir un sous-ensemble de modifications parmi une série de modifications (généralement des commits), et les enregistrer en tant que nouvelle série par-dessus un codebase différent. Dans Git, c'est la commande git cherry-pick qui s'en charge.",
      "child team": "Équipe enfant : dans des équipes imbriquées, la sous-équipe qui hérite des @mentions et des autorisations d'accès de l'équipe parente.",
      "clean": "Une arborescence de travail est propre si elle correspond à la révision référencée par le HEAD actuel. Voir aussi dirty (incorrectes).",
      "clustering": "Capacité à exécuter des services GitHub Enterprise parmi plusieurs nœuds et à équilibrer la charge des requêtes entre eux.",
      "code frequency graph": "Graphique de fréquence de code : graphique de dépôt qui montre les ajouts et suppressions de contenu pour chaque semaine dans l'historique d'un dépôt.",
      "code of conduct": "Code de conduite : document qui définit les standards d'engagement dans une communauté.",
      "code owner": "Propriétaire de code : personne désignée comme propriétaire d'une portion du code d'un dépôt. Le propriétaire de code reçoit automatiquement une demande de révision lorsque quelqu'un ouvre une demande de tirage qui apporte des modifications au code dont il est propriétaire.",
      "collaborator": "Collaborateur : personne ayant un accès en lecture et en écriture à un dépôt, et ayant été invité à contribuer par le propriétaire du dépôt.",
      "commit author": "Auteur de commit : utilisateur effectuant le commit.",
      "commit graph": "Graphe de commit : graphe de dépôt qui montre tous les commits effectués dans un dépôt durant l'année écoulée.",
      "commit ID": "ID de commit, également appelé SHA : hachage de somme de contrôle de 40 caractères qui identifie le commit.",
      "compare branch": "Branche de comparaison : branche que vous avez utilisée pour créer une demande de tirage, comparée à la branche de base. Également appelée « branche de tête » de la demande de tirage.",
      "continuous integration": "Intégration continue (CI) : processus qui exécute des builds et des tests automatisés une fois qu'une personne a commité une modification dans un dépôt configuré sur GitHub.",
      "contribution graph": "Graphe de contribution : partie du profil d'un utilisateur qui montre ses contributions sur une période maximale d'une année, jour par jour.",
      "contribution guidelines": "Instructions de contribution : document expliquant aux gens comment contribuer à votre projet.",
      "contributions": "Activités spécifiques sur GitHub qui ajoutent un carré au graphe de contribution d'un utilisateur ou des activités à la chronologie du profil.",
      "contributor": "Contributeur : quelqu'un qui n'a pas d'accès de collaborateur à un dépôt, mais qui a contribué à un projet et qui a ouvert une demande de tirage ayant été par la suite fusionnée dans le dépôt.",
      "contributors graph": "Graphe de contributeurs : graphe de dépôt qui affiche les 100 principaux contributeurs à un dépôt.",
      "coupon": "Code fourni par GitHub que les utilisateurs ou les organisations peuvent utiliser pour payer tout ou une partie de leur abonnement.",
      "cron": "Planificateur de travaux basé sur le temps dans les systèmes d'exploitation de type Unix.",
      "cURL": "Utilisé sur les lignes de commande ou dans les scripts pour transférer des données.",
      "dashboard": "Votre tableau de bord personnel est le hub principal de votre activité sur GitHub. À partir de votre tableau de bord personnel, vous pouvez effectuer le suivi des problèmes et des demandes de tirage que vous suivez ou sur lesquelles vous travaillez, accéder à vos principaux dépôts et pages d'équipes, et découvrir l'activité récente dans les dépôts que vous surveillez ou auxquels vous participez.",
      "default branch": "Branche par défaut : branche de base pour les nouvelles demandes de tirage et les nouveaux commits de code dans un dépôt. La première branche s'appelle généralement main.",
      "dependency graph": "Graphe des dépendances : graphe de dépôt qui montre les packages et les projets dont dépend le dépôt.",
      "dependents graph": "Graphe des éléments dépendants : graphe de dépôt qui montre les packages, les projets et les dépôts qui dépendent d'un dépôt public.",
      "deploy key": "Clé de déploiement : clé SSH qui est stockée sur votre serveur et qui accorde l'accès à un dépôt GitHub unique. Cette clé est attachée directement au dépôt, plutôt qu'à un compte d'utilisateur personnel.",
      "detached HEAD": "HEAD détaché : Git vous avertira si vous travaillez sur un HEAD détaché, ce qui signifie que Git ne pointe pas vers une branche et que les commits que vous apporterez n'apparaîtront pas dans l'historique des commits.",
      "diagnostics": "Diagnostics : vue d'ensemble des paramètres et de l'environnement d'une instance de GitHub Enterprise.",
      "diff": "Une diff est la différence de modification entre deux commits, ou modifications enregistrées. La diff décrit visuellement ce qui a été ajouté ou supprimé d'un fichier depuis son dernier commit.",
      "directory": "Répertoire (directory) : dossier contenant un ou plusieurs fichiers ou dossiers. Vous pouvez créer des répertoires afin d'organiser le contenu d'un dépôt.",
      "dirty": "Une arborescence de travail est considérée comme « sale » (incorrectes) si elle contient des modifications qui n'ont pas été commitées dans la branche actuelle.",
      "email notifications": "Notifications par e-mail : notifications envoyées à l'adresse e-mail d'un utilisateur.",
      "enterprise account": "Compte d'entreprise : les comptes d'entreprise vous permettent de gérer de manière centralisée la stratégie et la facturation pour plusieurs organisations.",
      "Explorer": "Instance de GraphiQL, qui est un « IDE GraphQL interactif graphique dans le navigateur ».",
      "fetch": "Lorsque vous utilisez git fetch, vous ajoutez des modifications à partir du dépôt distant à votre branche de travail locale sans les commiter. Contrairement à git pull, la récupération vous permet de passer en revue les modifications avant de les commiter dans votre branche locale.",
      "fenced code block": "Bloc de code délimité : bloc de code mis en retrait que vous pouvez créer avec GitHub Flavored Markdown en plaçant des triples accents graves avant et après le bloc de code.",
      "following (users)": "Suivre (utilisateurs) : recevoir des notifications concernant les contributions et l'activité d'un autre utilisateur.",
      "force push": "Poussée forcée : poussée Git qui écrit les modifications locales sur le dépôt distant sans se soucier des conflits.",
      "fork": "Duplication (fork) : copie personnelle du dépôt d'un autre utilisateur qui réside sur votre compte. Les duplications vous permettent d'apporter librement des modifications à un projet sans affecter le dépôt d'origine en amont. Vous pouvez aussi ouvrir une demande de tirage dans le dépôt en amont et maintenir votre duplication synchronisée avec les dernières modifications.",
      "Free plan": "Plan Gratuit : plan de facturation de compte d'utilisateur qui est gratuit. Les utilisateurs peuvent collaborer sur un nombre illimité de dépôts publics avec un nombre illimité de collaborateurs.",
      "gist": "Un gist est un fichier partageable que vous pouvez modifier, cloner et dupliquer sur GitHub. Vous pouvez rendre un gist public ou secret.",
      "gitfile": "Fichier .git brut qui est toujours à la racine d'une arborescence de travail et pointe vers le répertoire Git, qui contient le dépôt Git entier et ses métadonnées.",
      "GitHub App": "Application GitHub : les applications GitHub fournissent un service à une organisation entière et utilisent leur propre identité. Elles peuvent être installées directement sur des comptes d'utilisateur et des organisations, et il est possible de leur accorder l'accès à des dépôts spécifiques.",
      "GitHub Flavored Markdown": "Markdown propre à GitHub, utilisé pour mettre en forme la prose et le code dans GitHub.",
      "GitHub Importer": "Outil qui importe rapidement des dépôts de code source, y compris les commits et l'historique des révisions, sur GitHub pour les utilisateurs.",
      "GitHub Jobs": "Site GitHub où les employeurs peuvent publier des offres d'emplois susceptibles d'intéresser les utilisateurs de GitHub.",
      "GitHub Marketplace": "Sous-site à partir duquel les utilisateurs et les organisations GitHub peuvent acheter et installer des applications qui étendent et complètent leur workflow.",
      "GitHub Pages": "Également dénommé Pages. Service d'hébergement de site statique conçu pour héberger vos pages personnelles, de projet ou d'organisation directement à partir d'un dépôt GitHub.",
      "GitHub Wiki": "Wiki GitHub : section destinée à l'hébergement de documentation de style wiki sur un dépôt GitHub.",
      "GraphQL": "Langage de requête pour les API et runtime pour répondre à ces requêtes avec vos données existantes.",
      "HEAD": "Commit défini d'une branche, souvent le commit le plus récent au sommet de la branche.",
      "head branch": "Branche de tête : branche dont les modifications sont combinées dans la branche de base lorsque vous fusionnez une demande de tirage. Également appelée « branche de comparaison ».",
      "Hello, World": "Application « Hello, World! » : programme informatique qui génère ou affiche le message « Hello, World! » à un utilisateur. Souvent utilisé comme exemple de la syntaxe de base d'un langage de programmation.",
      "high-availability": "Haute disponibilité : système ou composant qui est opérationnel en continu pendant une période suffisamment longue.",
      "hook": "Lors de l'exécution normale de plusieurs commandes Git, des appels sont effectués à des scripts facultatifs qui permettent à un développeur d'ajouter une fonctionnalité ou une vérification.",
      "hostname": "Surnoms lisibles par l'homme qui correspondent à l'adresse d'un appareil connecté à un réseau.",
      "identicon": "Image générée automatiquement, utilisée comme photo de profil par défaut lorsque les utilisateurs s'inscrivent sur GitHub. Les utilisateurs peuvent remplacer leur identicon par leur propre photo de profil.",
      "identity provider": "Fournisseur d'identité (IdP) : fournisseur approuvé qui vous permet d'utiliser l'authentification unique (SSO) SAML pour accéder à d'autres sites web.",
      "instance": "Copie privée de GitHub contenue dans une machine virtuelle et appartenant à une organisation, qui la configure et la contrôle.",
      "integration": "Application tierce qui s'intègre à GitHub. Il s'agit souvent de GitHub Apps, GitHub Actions ou d'actions personnalisées.",
      "issue": "Les problèmes sont des suggestions d'améliorations, des tâches ou des questions en rapport avec le dépôt. Les problèmes peuvent être créés par n'importe qui (pour les dépôts publics), et ils sont modérés par les collaborateurs du dépôt. Chaque problème contient son propre thread de discussion.",
      "Jekyll": "Générateur de site statique pour des sites personnels, de projet ou d'organisation.",
      "Jekyll Theme Chooser": "Sélecteur de thème Jekyll : moyen automatisé de sélectionner un thème visuel pour votre site Jekyll sans modifier ou copier des fichiers CSS.",
      "key fingerprint": "Empreinte digitale de clé : courte séquence d'octets permettant d'identifier une clé publique plus longue.",
      "keychain": "Système de gestion des mots de passe dans macOS.",
      "keyword": "Mot clé : mot spécifique qui ferme un problème en cas d'utilisation dans une demande de tirage.",
      "label": "Étiquette sur un problème ou une demande de tirage. Les dépôts sont fournis avec quelques étiquettes par défaut, mais les utilisateurs peuvent créer des étiquettes personnalisées.",
      "LFS": "Stockage de fichiers volumineux Git (LFS). Extension Git open source pour le versioning des grands fichiers.",
      "line comment": "Commentaire de ligne : commentaire dans une demande de tirage sur une ligne de code spécifique.",
      "line ending": "Fin de ligne : caractère(s) invisible(s) qui symbolise(nt) la fin d'une ligne dans un fichier texte.",
      "Linguist": "Bibliothèque utilisée sur GitHub pour détecter les langages blob, ignorer les fichiers binaires ou de fournisseurs, supprimer les fichiers générés dans les diffs, et générer des graphes de répartition de langage.",
      "locked personal account": "Compte personnel verrouillé : compte personnel inaccessible par l'utilisateur. Les comptes sont verrouillés lorsque des utilisateurs passent d'un compte payant à un compte gratuit, ou si leur plan payant a dépassé sa date d'échéance.",
      "management console": "Section de l'interface GitHub Enterprise qui contient des fonctionnalités d'administration.",
      "Markdown": "Markdown est un format de fichier sémantique incroyablement simple. GitHub prend en charge Markdown, et utilise une forme particulière de Markdown appelée GitHub Flavored Markdown.",
      "markup": "Balisage : système d'annotation et de mise en forme de document.",
      "master": "Branche par défaut dans de nombreux dépôts Git. Par défaut, lorsque vous créez un dépôt Git sur la ligne de commande, une branche nommée master est créée. De nombreux outils utilisent maintenant main pour la branche par défaut.",
      "members graph": "Graphe de membres : graphe de dépôt qui montre toutes les duplications d'un dépôt.",
      "mention": "Notification envoyée à un utilisateur en préfixant son nom d'utilisateur du symbole @. Les utilisateurs dans une organisation sur GitHub peuvent également faire partie d'une équipe qui peut être mentionnée.",
      "milestone": "Manière de suivre la progression des groupes de problèmes ou de demandes de tirage dans un dépôt.",
      "mirror": "Nouvelle copie d'un dépôt.",
      "nested team": "Équipe imbriquée : équipe enfant d'une équipe parente. Vous pouvez avoir plusieurs équipes enfants (ou imbriquées).",
      "network graph": "Graphe réseau : graphe de dépôt qui montre l'historique des branches de tout le réseau du dépôt, y compris les branches du dépôt racine et celles des duplications qui contiennent des commits uniques au réseau.",
      "news feed": "Échange de News : vue des actualités des dépôts ou personnes que vous suivez. Le flux d'actualités d'une organisation montre l'activité des dépôts appartenant à l'organisation.",
      "non-fast-forward": "Lorsque votre copie locale d'un dépôt n'est plus synchronisée avec le dépôt en amont et que vous devez récupérer les modifications en amont avant de pousser vos modifications locales.",
      "notification": "Mises à jour remises par le biais du web ou d'un e-mail, en fonction de vos paramètres, et qui vous fournissent des informations concernant les activités qui vous intéressent.",
      "OAuth app": "Application OAuth : application tierce qui utilise des jetons d'accès plutôt que des mots de passe pour accéder aux informations pour les utilisateurs.",
      "OAuth token": "Jeton OAuth : jeton d'accès utilisé par les applications OAuth pour accéder aux informations des utilisateurs.",
      "organization": "Les organisations sont des groupes de plusieurs utilisateurs, qui correspondent en générale à des organisations dans le monde réel. Elles sont administrées par des utilisateurs, et peuvent contenir à la fois des dépôts et des équipes.",
      "organization owner": "Propriétaire d'organisation : utilisateurs ayant un accès d'administration complet à l'organisation dont ils sont propriétaires.",
      "outside collaborator": "Collaborateur externe : utilisateur à qui a été accordé l'accès à un ou plusieurs dépôts d'une organisation, mais qui n'a pas d'autre accès à l'organisation et n'en est pas membre.",
      "owner": "Propriétaire : membres d'une organisation ayant un accès d'administration complet à l'organisation.",
      "parent team": "Équipe parente : au sein d'équipes imbriquées, l'équipe principale à partir de laquelle les équipes enfants héritent des autorisations d'accès et des @mentions.",
      "participating notifications": "Notifications de participation : notification relative à une mise à jour dans une conversation, un problème ou une demande de tirage, où votre nom d'utilisateur ou votre équipe a été mentionné, ou où vous avez précédemment répondu à un commentaire.",
      "permalink": "Lien permanent : lien hypertexte statique permanent vers une page web particulière.",
      "personal account": "Compte personnel : compte GitHub qui appartient à un utilisateur individuel.",
      "pinned repository": "Dépôt épinglé : dépôt qu'un utilisateur a décidé d'afficher de manière proéminente sur son profil.",
      "pre-receive hooks": "Hooks de pré-réception : scripts qui s'exécutent sur le serveur GitHub Enterprise, que vous pouvez utiliser pour implémenter des contrôles de la qualité.",
      "primary email address": "Adresse e-mail principale à laquelle GitHub envoie les reçus, les frais de carte bancaire ou PayPal, et autres communications en rapport avec la facturation.",
      "private contributions": "Contributions privées : contributions apportées à un dépôt privé (plutôt que public).",
      "private repository": "Dépôt privé : les dépôts privés sont visibles uniquement par le propriétaire du dépôt et par les collaborateurs spécifiés par le propriétaire.",
      "production branch": "Branche de production : branche contenant les modifications finales qui sont prêtes à être utilisées ou déployées sur une application ou un site.",
      "profile": "Page qui montre des informations concernant l'activité d'un utilisateur sur GitHub.",
      "profile picture": "Photo de profil : image personnalisée que les utilisateurs chargent sur GitHub pour identifier leur activité, généralement accompagnée de leur nom d'utilisateur. Également appelée « avatar ».",
      "project board": "Tableau d'un projet : tableaux dans GitHub qui sont constitués de problèmes, de demandes de tirage et de notes classés en catégories sous forme de cartes dans des colonnes.",
      "protected branch": "Branche protégée : les branches protégées bloquent plusieurs fonctionnalités de Git sur une branche qu'un administrateur de dépôt choisit de protéger. Elles ne peuvent pas subir de poussée forcée, de suppression, de fusion de modifications sans que des contrôles requis soient effectués ou que des révisions soient approuvées.",
      "public contributions": "Contributions publiques : contributions apportées à un dépôt public (plutôt que privé).",
      "public repository": "Dépôt public : un dépôt public peut être affiché par n'importe qui, y compris des personnes qui ne sont pas des utilisateurs de GitHub.",
      "pull access": "Synonyme d'accès en lecture (accès de tirage).",
      "pull request review": "Révision de demande de tirage : commentaires de la part des collaborateurs sur une demande de tirage qui approuvent les modifications ou demandent davantage de modifications avant que la demande soit fusionnée.",
      "pulse graph": "Graphe de pulsation : graphe de dépôt qui fournit une vue d'ensemble de l'activité d'un dépôt.",
      "punch graph": "Graphe punch : graphe de dépôt qui indique la fréquence des mises à jour d'un dépôt en fonction du jour de la semaine et de l'heure de la journée.",
      "push a branch": "Pousser une branche : lorsque vous poussez une branche vers un dépôt distant, vous mettez à jour la branche distante avec les modifications de votre branche locale.",
      "push access": "Synonyme d'accès en écriture (accès de poussée).",
      "read access": "Accès en lecture : niveau d'autorisation sur un dépôt qui permet à l'utilisateur de tirer, ou lire, des informations à partir du dépôt. Tous les dépôts publics donnent un accès en lecture à tous les utilisateurs GitHub. Synonyme d'accès de tirage.",
      "recovery code": "Code de récupération : code qui vous aide à récupérer l'accès à votre compte GitHub.",
      "release": "Moyen par lequel GitHub empaquette et fournit des logiciels à vos utilisateurs.",
      "remote repository": "Dépôt distant : dépôt utilisé pour assurer le suivi du même projet, mais qui réside ailleurs.",
      "remote URL": "URL distante : emplacement où votre code est stocké ; il s'agit d'un dépôt sur GitHub, de la duplication d'un autre utilisateur, ou même d'un autre serveur.",
      "replica": "Réplica : instance de GitHub Enterprise qui fournit une redondance pour l'instance principale de GitHub Enterprise.",
      "repository cache": "Cache de dépôt : miroir en lecture seule de dépôts pour votre instance de serveur GitHub Enterprise ; situé près des équipes distribuées et des clients CI.",
      "repository graph": "Graphe de dépôt : représentation visuelle des données de votre dépôt.",
      "repository maintainer": "Mainteneur de dépôt : personne qui gère un dépôt. Cette personne peut aider à trier les problèmes, et utiliser des étiquettes et d'autres fonctionnalités pour gérer le travail du dépôt.",
      "required pull request review": "Révision de demande de tirage requise : les révisions requises garantissent que les demandes de tirage ont au moins une révision approuvée avant que les collaborateurs puissent apporter des modifications à une branche protégée.",
      "required status check": "Vérification d'état requise : vérifications sur des demandes de tirage qui garantissent que tous les tests CI requis ont réussi avant que des collaborateurs puissent apporter des modifications à une branche protégée.",
      "revert": "Lorsque vous rétablissez une demande de tirage sur GitHub, une nouvelle demande de tirage est générée automatiquement ; celle-ci contient un commit qui rétablit le commit de fusion à partir de la demande de tirage fusionnée d'origine. Dans Git, vous pouvez rétablir des commits avec git revert.",
      "review": "Revue : les révisions permettent aux autres personnes ayant accès à votre dépôt de commenter les modifications proposées dans les demandes de tirage, d'approuver les modifications ou de demander d'autres modifications avant la fusion de la demande de tirage.",
      "root directory": "Répertoire racine : premier répertoire dans une hiérarchie.",
      "root filesystem": "Système de fichiers racine : système d'exploitation de base et environnement d'application GitHub Enterprise.",
      "saved reply": "Réponse enregistrée : commentaire que vous pouvez enregistrer et ajouter à votre compte d'utilisateur GitHub afin de pouvoir l'utiliser dans tout GitHub dans les problèmes et les demandes de tirage.",
      "scope": "Groupes d'autorisations nommés qu'une application OAuth ou un personal access token (classic) peut demander pour accéder aux données publiques et non publiques.",
      "seat": "Siège : utilisateur au sein d'une organisation GitHub Enterprise. Également parfois appelé « compte de siège ».",
      "secret team": "Équipe secrète : équipe visible uniquement par les autres membres de l'équipe et les personnes disposant d'autorisations de propriétaire.",
      "security log": "Journal de sécurité : journal listant les 50 dernières actions ou celles effectuées au cours des 90 derniers jours.",
      "server-to-server request": "Requête serveur à serveur : requête d'API utilisée par une application qui agit en tant que bot, indépendamment de tout utilisateur particulier. Le jeton utilisé est acquis programmatiquement, via l'API GitHub.",
      "service hook": "Crochet de service : également appelé « webhook ». Les webhooks permettent de remettre des notifications à un serveur web externe chaque fois que certaines actions se produisent sur un dépôt ou une organisation.",
      "single sign-on": "Authentification unique (SSO) : permet aux utilisateurs de se connecter à un emplacement unique (un fournisseur d'identité, IdP) qui accorde ensuite à l'utilisateur l'accès à d'autres fournisseurs de service.",
      "squash": "Squashing : combinaison de plusieurs commits en un commit unique. « squash » est également une commande Git.",
      "SSH key": "Clé SSH : les clés SSH sont un moyen de vous identifier auprès d'un serveur en ligne, à l'aide d'un message chiffré. GitHub utilise des clés SSH pour transférer en toute sécurité des informations vers votre ordinateur.",
      "staging instance": "Instance intermédiaire : manière de tester des modifications avant qu'elles soient appliquées à votre instance GitHub Enterprise.",
      "star": "Étoile : signet, ou signe d'appréciation pour un dépôt. Les étoiles permettent d'évaluer manuellement la popularité des projets.",
      "status": "Représentation visuelle dans une demande de tirage indiquant que vos commits remplissent les conditions définies pour le dépôt auquel vous contribuez.",
      "status checks": "Vérifications d'état : processus externes, tels que des builds d'intégration continue, qui s'exécutent pour chaque commit que vous effectuez dans un dépôt.",
      "subscription": "Abonnement : plan GitHub d'un utilisateur ou d'une organisation.",
      "team": "Groupe de membres d'une organisation qui reflète la structure de votre entreprise ou de votre groupe avec des mentions et des autorisations d'accès en cascade.",
      "team maintainer": "Responsable d'équipe : membre d'une organisation disposant d'un sous-ensemble d'autorisations permettant aux propriétaires d'organisation de gérer des équipes.",
      "Team plan": "Plan d'équipe : plan de facturation d'organisation qui vous procure une quantité illimitée de dépôts publics et privés.",
      "timeline": "Chronologie : série d'événements dans une demande de tirage ou sur un profil utilisateur.",
      "topic branch": "Branche de rubrique : branche Git ordinaire utilisée par un développeur pour identifier une ligne de développement conceptuelle. Peut également être appelée « branche de fonctionnalité ».",
      "topics": "Manière d'explorer des dépôts dans un domaine particulier, de rechercher des projets auxquels contribuer, et de découvrir de nouvelles solutions à un problème spécifique sur GitHub.",
      "traffic graph": "Graphe de trafic : graphe de dépôt qui montre le trafic d'un dépôt, y compris les clones complets (pas les récupérations), les visiteurs des 14 derniers jours, les sites de référence et le contenu populaire.",
      "transfer": "Transférer : transférer un dépôt signifie en changer le propriétaire. Le nouveau propriétaire sera en mesure d'administrer le contenu, les problèmes, les demandes de tirage, les mises en production et les paramètres du dépôt.",
      "upstream branch": "Branche en amont : branche par défaut qui est fusionnée dans la branche en question (ou sur laquelle la branche en question est rebasée). Elle est configurée via branch.<name>.remote et branch.<name>.merge. Si la branche en amont de A est l'origine/B, nous employons parfois l'expression « A effectue le suivi de l'origine/B ».",
      "user": "Utilisateur : les utilisateurs sont des personnes ayant des comptes GitHub personnels. Chaque utilisateur a un profil personnel, et peut être propriétaire de plusieurs dépôts, publics ou privés.",
      "user-to-server request": "Requête utilisateur à serveur : requête d'API utilisée par une application qui effectue une tâche pour le compte d'un utilisateur particulier. Le jeton utilisé est acquis via OAuth.",
      "username": "Descripteur d'un utilisateur sur GitHub.",
      "visible team": "Équipe visible : équipe pouvant être vue et mentionnée (@mentioned) par chaque membre de l'organisation.",
      "watch": "Vous pouvez surveiller un dépôt ou un problème afin de recevoir des notifications lorsque des mises à jour sont apportées à un problème ou à une demande de tirage.",
      "watching notifications": "Notifications de surveillance : notification concernant une activité dans un dépôt auquel un abonné s'est inscrit.",
      "web notifications": "Notifications affichées dans l'interface web sur GitHub.",
      "webhooks": "Les webhooks vous permettent de générer ou de configurer des applications GitHub qui s'abonnent à certains événements sur GitHub.com. Les webhooks permettent de remettre des notifications à un serveur web externe chaque fois que certaines actions se produisent sur un dépôt ou une organisation. Également appelé crochet de service.",
      "write access": "Accès en écriture : niveau d'autorisation sur un dépôt qui permet à l'utilisateur de pousser, ou écrire, des modifications dans le dépôt."
    },
    "cheatsheet": {
      "sections": [
        {
          "title": "1. Contrôle de version",
          "paragraphs": [
            "Définition : Une façon de sauvegarder et de suivre l'évolution de vos fichiers dans le temps. Un seul projet, un historique de chaque modification : qui a changé quoi, et quand. Vous pouvez revenir à n'importe quelle version antérieure.",
            "Pourquoi c'est important : Sans contrôle de version, il est facile de perdre du travail, d'écraser les changements d'un collègue ou d'oublier ce qu'on a modifié. Avec lui, vous avez un historique clair et pouvez collaborer en toute sécurité.",
            "Pour les humanités numériques : Les éditions, corpus, jeux de données et sites web impliquent souvent des équipes, des itérations sur des années, et le besoin de citer ou reproduire un état précis du projet. Beaucoup de financeurs et d'éditeurs attendent ou recommandent le contrôle de version pour la transparence et la reproductibilité."
          ]
        },
        {
          "title": "2. Bases de Git",
          "subsections": [
            {
              "title": "Qu'est-ce que Git ?",
              "list": [
                "Outil gratuit et open source pour le contrôle de version sur votre ordinateur.",
                "Fonctionne en local : tout l'historique est dans un dossier caché (un dépôt) à l'intérieur du projet.",
                "Pas besoin d'internet pour faire des commits—seulement pour partager ou sauvegarder (ex. avec GitHub)."
              ]
            },
            {
              "title": "Commandes essentielles",
              "items": [
                { "cmd": "git init", "desc": "Transformer le dossier actuel en dépôt Git" },
                { "cmd": "git add <fichier> ou git add .", "desc": "Mettre des fichiers en stage pour le prochain commit" },
                { "cmd": "git commit -m \"Votre message\"", "desc": "Créer une photo du projet avec un message court" },
                { "cmd": "git status", "desc": "Voir les fichiers modifiés, en stage et non suivis" },
                { "cmd": "git log", "desc": "Voir l'historique des commits" },
                { "cmd": "git log --oneline", "desc": "Vue compacte de l'historique (une ligne par commit)" }
              ]
            },
            {
              "title": "Workflow",
              "list": [
                "Créer ou modifier des fichiers.",
                "git add les fichiers à inclure.",
                "git commit -m \"Message clair et court\".",
                "Utiliser git status souvent pour éviter de committer les mauvais fichiers."
              ]
            },
            {
              "title": ".gitignore",
              "list": [
                "Fichier qui liste des motifs (un par ligne). Git ignore les fichiers correspondants : ils n'apparaissent pas comme non suivis et ne sont pas ajoutés avec git add .",
                "À utiliser pour : secrets, clés API, fichiers de build, config locale, caches, sauvegardes d'éditeur.",
                "Créer avec : edit .gitignore (dans le tutoriel) ou n'importe quel éditeur. Commiter .gitignore pour partager les règles."
              ]
            },
            {
              "title": "Corriger les erreurs",
              "items": [
                { "cmd": "git restore --staged <fichier>", "desc": "Retirer un fichier du stage (l'enlever du prochain commit)" },
                { "cmd": "git restore <fichier>", "desc": "Annuler les changements non commités dans ce fichier (à utiliser avec précaution)" },
                { "cmd": "git commit --amend -m \"Nouveau message\"", "desc": "Remplacer le message du dernier commit (ou y intégrer des changements en stage)" },
                { "cmd": "git reset --soft HEAD~1", "desc": "Annuler le dernier commit en gardant les changements en stage" }
              ]
            }
          ]
        },
        {
          "title": "3. Branches",
          "paragraphs": [
            "Branche : Ligne de développement séparée. Vous pouvez tester des changements ou travailler sur des fonctionnalités sans toucher à la ligne principale.",
            "Pourquoi : Essentiel pour expérimenter, travailler sur des fonctionnalités à part et collaborer. En HN, une branche peut servir pour une variante d'édition ou une mise à jour de jeu de données."
          ],
          "subsections": [
            {
              "title": "Commandes",
              "items": [
                { "cmd": "git branch", "desc": "Lister les branches (* = courante)" },
                { "cmd": "git checkout -b <nom>", "desc": "Créer et passer sur une nouvelle branche" },
                { "cmd": "git checkout <nom>", "desc": "Passer sur une branche existante" },
                { "cmd": "git merge <branche>", "desc": "Fusionner cette branche dans la branche courante" },
                { "cmd": "git merge --squash <branche>", "desc": "Apporter les changements de l'autre branche en un seul ensemble en stage ; vous commitez une fois (pas de commit de merge)" },
                { "cmd": "git rebase <branche>", "desc": "Déplacer vos commits pour qu'ils reposent sur l'autre branche (historique linéaire)" },
                { "cmd": "git branch -d <nom>", "desc": "Supprimer une branche fusionnée (pour garder la liste lisible)" }
              ]
            },
            {
              "title": "Conflits de fusion",
              "list": [
                "Quand deux branches modifient la même partie du même fichier, Git ne peut pas fusionner automatiquement.",
                "Le fichier est marqué avec des marqueurs de conflit : <<<<<<<, =======, >>>>>>>.",
                "Résoudre : Ouvrir le fichier, choisir le contenu final (garder une version, combiner ou modifier), supprimer les marqueurs et la version non voulue, puis git add le fichier et git commit."
              ]
            }
          ]
        },
        {
          "title": "4. GitHub",
          "paragraphs": [
            "Définition : Site qui héberge des dépôts Git dans le cloud. Sauvegarde, historique visible en ligne et outils pour collaborer : les autres peuvent cloner, proposer des changements (pull requests), et vous pouvez gérer les issues et la documentation.",
            "Lien avec Git : Git est local ; GitHub est distant. Ensemble ils permettent de sauvegarder, partager et collaborer."
          ],
          "subsections": [
            {
              "title": "Créer un dépôt sur GitHub",
              "list": [
                "Sur GitHub : New repository → choisir un nom (ex. mon-projet-hn) → vous obtenez une URL pour connecter votre dépôt local."
              ]
            },
            {
              "title": "Distant, push et pull",
              "items": [
                { "cmd": "git remote add origin <URL>", "desc": "Lier votre dépôt local au distant (ex. GitHub)" },
                { "cmd": "git push -u origin main", "desc": "Premier push : envoyer les commits et définir l'upstream" },
                { "cmd": "git push", "desc": "Envoyer vos commits vers le distant" },
                { "cmd": "git pull", "desc": "Récupérer et fusionner les changements depuis le distant" },
                { "cmd": "git clone <URL>", "desc": "Télécharger une copie complète d'un dépôt (crée un nouveau dossier)" }
              ]
            },
            {
              "title": "Conseil",
              "paragraphs": ["Faire git pull avant git push pour éviter les rejets quand d'autres ont poussé."]
            }
          ]
        },
        {
          "title": "5. Collaboration et bonnes pratiques",
          "list": [
            "Utiliser des branches pour des lignes de travail séparées ; utiliser les pull requests sur GitHub pour proposer et faire revue des changements avant de fusionner.",
            "Committer souvent avec des messages clairs et courts. Envisager les Conventional Commits (ex. feat:, fix:, docs:) pour la cohérence — voir https://www.conventionalcommits.org/en/v1.0.0/.",
            "Pousser régulièrement pour sauvegarder le travail.",
            "Ajouter un README (ex. README.md) pour expliquer le projet et comment l'utiliser ou contribuer.",
            "Ajouter une licence pour que les autres sachent comment réutiliser vos données et votre code.",
            "Une branche par fonctionnalité ou correctif, puis fusionner quand c'est prêt."
          ]
        },
        {
          "title": "6. Aide-mémoire des commandes",
          "subsections": [
            { "title": "Configuration", "code": "git config user.name \"Votre nom\"\ngit config user.email \"votre@email.com\"\ngit init" },
            { "title": "Workflow de base", "code": "git status\ngit add <fichier>   # ou git add .\ngit commit -m \"message\"\ngit log" },
            { "title": "Branches", "code": "git branch\ngit checkout -b <branche>\ngit checkout <branche>\ngit merge <branche>\ngit merge --squash <branche>\ngit rebase <branche>\ngit branch -d <branche>" },
            { "title": "Distant (GitHub)", "code": "git remote add origin <URL>\ngit push -u origin main\ngit push\ngit pull\ngit clone <URL>" },
            { "title": "Utile", "code": "git log --oneline\ngit remote -v\ngit restore --staged <fichier>\ngit restore <fichier>\ngit commit --amend -m \"Nouveau message\"" }
          ]
        },
        {
          "title": "7. Termes clés (glossaire)",
          "items": [
            { "cmd": "Dépôt (repository / repo)", "desc": "Dossier géré par Git ; contient les fichiers du projet et tout l'historique des commits." },
            { "cmd": "Commit", "desc": "Photo du projet à un instant donné, avec un message et un identifiant unique." },
            { "cmd": "Stage / staged", "desc": "Marquer des fichiers comme prêts pour le prochain commit avec git add." },
            { "cmd": "Remote / origin", "desc": "Version du dépôt hébergée ailleurs (ex. GitHub) ; origin est le nom par défaut." },
            { "cmd": "Push / Pull / Clone", "desc": "Push : envoyer les commits locaux vers un distant. Pull : récupérer et fusionner depuis le distant. Clone : télécharger une copie complète d'un dépôt." },
            { "cmd": "Branche / Merge", "desc": "Branche : ligne de développement séparée. Merge : fusionner une autre branche dans la branche courante." },
            { "cmd": "Conflit de fusion", "desc": "Même partie du même fichier modifiée dans deux branches ; on résout en éditant le fichier et en supprimant les marqueurs." },
            { "cmd": "Untracked / .gitignore", "desc": "Untracked : fichier que Git ne suit pas encore. .gitignore : fichier listant les motifs que Git doit ignorer." }
          ]
        },
        {
          "title": "8. Prochaines étapes (sur votre ordinateur)",
          "list": [
            "Installer Git : https://git-scm.com/ (ou votre gestionnaire de paquets).",
            "Créer un compte GitHub : https://github.com",
            "Configurer l'authentification pour pouvoir pousser et tirer : clés SSH (recommandé), ou jeton d'accès personnel en HTTPS. Voir la doc GitHub : « Connecting to GitHub with SSH » et « Managing your personal access tokens ».",
            "Une fois Git installé et l'authentification configurée, vous pourrez cloner des dépôts, pousser votre travail et ouvrir des pull requests en ligne de commande ou avec une interface graphique."
          ],
          "paragraphs": ["Tutoriel : https://humanities-data-lab.github.io/learn-git-and-github/"]
        }
      ]
    }
  }
}
