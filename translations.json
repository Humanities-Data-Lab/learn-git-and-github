{
  "en": {
    "ui": {
      "title": "Learn Git and GitHub",
      "subtitle": "Version control from zero — Essential for Digital Humanities",
      "welcome": "Welcome to Git and GitHub!",
      "welcomeDescription": "This interactive tutorial teaches version control from the ground up. No prior knowledge of Git, GitHub, or version control is assumed. You'll learn why these tools matter—especially for Digital Humanities projects—and how to use them. Everything is done in the terminal and file editor on this page: you do not need to use your computer's terminal or install Git.",
      "tutorialCredit": "Made by Asher Lacho in coordination with the Humanities Data Lab. This tutorial follows the same module system as the HTML/CSS course. It is available in English and French.",
      "enterName": "Enter your name",
      "chooseAvatar": "Choose your avatar",
      "chooseAvatarOption": "Avatar option {number} of {total}",
      "avatarPickerScrollHint": "Scroll for more avatars",
      "changeAvatar": "Change avatar",
      "createYourAvatar": "Create your avatar",
      "avatarSkinTone": "Skin tone",
      "avatarHairStyle": "Hair style",
      "avatarHairColor": "Hair color",
      "avatarClothingStyle": "Clothing style",
      "avatarClothingColor": "Clothing color",
      "avatarMouth": "Mouth",
      "avatarEyes": "Eyes",
      "avatarAccessories": "Glasses & accessibility",
      "avatarAccessoriesColor": "Glasses / accessory color",
      "avatarEyebrows": "Eyebrows",
      "avatarFacialHair": "Facial hair",
      "avatarFacialHairColor": "Facial hair color",
      "avatarHatColor": "Hat / headwear color",
      "avatarClothingGraphic": "Shirt graphic",
      "addColor": "Add color",
      "addColorHint": "Click a swatch to change the colour; add more to give the avatar alternate shades.",
      "removeColor": "Remove",
      "done": "Done",
      "randomizeAvatar": "Randomize avatar",
      "startLearning": "Start Learning",
      "nameCertificateNote": "This name will appear on your shareable certificate when you complete all lessons.",
      "welcomeUser": "Welcome, {name}! • Lesson {current} of {total}",
      "courseProgress": "Course Progress - Click any section to jump to it",
      "whatWeLearning": "What we're learning:",
      "whyImportant": "Why it's important:",
      "needHint": "Need a hint? Click to see what to do",
      "hideHint": "Hide hint",
      "showHint": "Show hint",
      "whatToDo": "What to do:",
      "commandsToTry": "Command(s) to try",
      "copyCommand": "Copy command",
      "terminalHint": "Use the terminal on the right to run the command.",
      "terminalNavHint": "Commands: ls, pwd, cd, cat, echo, edit | git ... | next | back | clear",
      "editorLabel": "File editor",
      "save": "Save",
      "cancel": "Cancel",
      "back": "← Back",
      "verifyCode": "I've done this →",
      "skip": "Skip →",
      "tryAgain": "Try Again",
      "nextLesson": "Next Lesson →",
      "learnMore": "Learn more",
      "tip": "Tip:",
      "copyUrl": "Copy this URL to save your progress and resume later:",
      "copyToClipboard": "Copy to clipboard",
      "copied": "Copied!",
      "noFilesSaved": "No data is saved on our server—this is the only way to re-access your progress.",
      "certificateTitle": "Certificate of Completion",
      "certificateSubtitle": "Git and GitHub for Version Control",
      "certificateDescription": "This certifies that",
      "certificateCompleted": "has successfully completed the interactive tutorial on version control, Git basics, and GitHub—with a focus on why these tools matter for Digital Humanities.",
      "certificateCovered": "This course covered:",
      "completedOn": "Completed on",
      "congratulations": "Congratulations",
      "certificateShare": "Share this certificate with anyone by copying the URL:",
      "certificateShareDescription": "You can copy the URL above to share your certificate.",
      "printCertificate": "Print Certificate",
      "emailCertificate": "Email Certificate",
      "emailCertificateSubject": "Check out my certificate",
      "emailCertificateBody": "I've completed the Git and GitHub tutorial! Check out my certificate:",
      "certificateItem1": "What is version control and why it matters for Digital Humanities",
      "certificateItem2": "Git basics: repositories, commits, and history",
      "certificateItemBranching": "Branching: create branches, merge, squash, and rebase",
      "certificateItem3": "GitHub: hosting, push, pull, and clone",
      "certificateItem4": "Collaboration and good practices for DH projects",
      "successMessage": "Well done! Continue to the next lesson when ready.",
      "errorMessage": "Not quite right. Make sure you: {elements}",
      "selectLanguage": "Select language",
      "studentNameAria": "Student name: {name}",
      "completed": "Completed",
      "jumpToSection": "Jump to {section} section. {completed} of {total} lessons completed.",
      "hintRegion": "Hint instructions",
      "glossaryButton": "Glossary",
      "glossaryTitle": "Glossary",
      "glossarySearchPlaceholder": "Search terms...",
      "glossaryClose": "Close glossary",
      "glossaryNoResults": "No terms match your search.",
      "cheatsheetButton": "Cheatsheet",
      "cheatsheetTitle": "Git & GitHub Cheatsheet",
      "cheatsheetPrint": "Print",
      "cheatsheetClose": "Close",
      "skipToMainContent": "Skip to main content",
      "definitionOf": "Definition of {term}",
      "backToLessons": "Back to lessons",
      "viewCertificate": "View certificate",
      "reportBug": "Report bug",
      "branchVisualizerHelpButton": "Help",
      "branchVisualizerHelpTitle": "About the branch graph",
      "branchVisualizerHelpBody": "This graph shows your Git branches and commits. Each dot is a commit (with its short hash and message). Branches appear as separate lines; the main branch and any branch you create (e.g. with git checkout -b) are shown. The label \"current\" shows which branch you're on. New branches appear as soon as you create them, even before you make a commit on them.",
      "lessonCompleteNext": "Lesson complete! Moving to next lesson...",
      "lessonCompleteTypeNext": "Lesson complete! Type \"next\" or click the button to continue.",
      "goingBackToLesson": "Going back to previous lesson.",
      "editUsage": "edit: usage: edit <filename>",
      "editingFile": "Editing {filename} (save or cancel in editor below)",
      "editFileReminder": "To edit a file here: type **edit** followed by the filename in the terminal (e.g. **edit readme.txt**); the editor opens below—make your changes and click Save.",
      "unsupportedGitCommand": "The command you entered may be valid in Git, but this tutorial's simulated environment doesn't support it—we only cover a subset of commands here."
    },
    "categories": {
      "tutorialIntro": "How this tutorial works",
      "versionControl": "Version Control",
      "gitBasics": "Git Basics",
      "branching": "Branching",
      "github": "GitHub",
      "collaboration": "Collaboration"
    },
    "lessons": {
      "intro-1": {
        "title": "The terminal: what works like the real thing",
        "description": "This tutorial has a **simulated terminal** on the right. Much of it behaves like a real terminal (e.g. on your Mac, Linux, or in VS Code). You type commands and see output; the prompt shows your current folder (**~/my-project**). Standard shell commands work as you’d expect: **ls** lists files, **pwd** shows the current directory, **cd** changes directory, **cat** shows file contents, and **echo** can create or append to files (e.g. **echo \"Hello\" > readme.txt**). So the way you navigate and run commands is very close to a real terminal.",
        "whyImportant": "Getting used to typing commands here will make the move to a real terminal or IDE much easier. The habits you build (reading the prompt, using ls and cat to see what’s there) transfer directly.",
        "whatToDo": [
          "Read the explanation above",
          "In the terminal, try **ls** or **pwd** to see they work like a normal shell",
          "Type **next** when you’re ready to continue"
        ]
      },
      "intro-2": {
        "title": "What we’ve simplified: edit command and Git simulation",
        "description": "A few things in this tutorial are **simplified or custom** so you can learn without installing anything. **Editing files:** In a real terminal you’d open a text editor (e.g. **nano**, **vim**, or open the file in an app). Here we use a built-in **edit** command: type **edit filename** (e.g. **edit readme.txt**) in the terminal and an **editor panel opens below**—change the content and click **Save**. That’s only for this tutorial. **Git:** We simulate Git in the browser. Commands like **git init**, **git add**, **git commit**, **git status**, **git branch**, **git merge**, **git remote**, **git push**, and **git pull** behave like real Git and teach the real workflow. But there is no real network: **git push** and **git pull** don’t talk to real servers—remotes and clones are simulated. You don't need to understand this right now—we'll cover remotes and clones in later lessons. So: terminal navigation and file commands are close to real; **edit** is tutorial-only; Git logic is real, but remotes are simulated.",
        "whyImportant": "Knowing what’s “real” vs “for this lesson” helps you know what to expect when you use Git and a terminal on your own machine. You’ll use a real editor and real GitHub; the concepts you learn here will still apply.",
        "whatToDo": [
          "Read the explanation above",
          "When a lesson asks you to edit a file, remember: type **edit** followed by the filename the lesson specifies (e.g. **edit readme.txt**) in the terminal, then use the editor below and click Save",
          "Type **next** when you’re ready to start the version control lessons"
        ]
      },
      "vc-1": {
        "title": "What is version control?",
        "description": "Version control is a way to save and track changes to your files over time. Instead of ending up with files like \"thesis_v1.docx\", \"thesis_final.docx\", and \"thesis_FINAL_really.docx\", you keep one project and a history of every change: who changed what, and when. You can go back to any earlier version if you need to.",
        "whyImportant": "Without version control, it's easy to lose work, overwrite someone else's changes, or forget what you changed. With it, you have a clear history and can collaborate safely. For Digital Humanities projects—editions, corpora, datasets, and websites—this is essential: you often work in teams, iterate over years, and need to cite or reproduce a specific state of the project.",
        "whatToDo": [
          "Read the explanation above",
          "Think of a project (e.g. a text edition or dataset) where you'd want to track every change",
          "In the terminal on the right, type **next** when you're ready to continue"
        ]
      },
      "vc-2": {
        "title": "Why version control matters for Digital Humanities",
        "description": "Digital Humanities projects usually involve texts, metadata, code, and often several people. Version control lets you: keep a single source of truth instead of scattered copies; see who added or changed which line; recover from mistakes; and give others (or future you) a way to understand and reproduce your work. Many funders and publishers now expect or recommend using version control for transparency and reproducibility.",
        "whyImportant": "DH work is research. Being able to show how a corpus or edition evolved, and to restore or cite a specific version, supports both scholarly practice and open science. Learning Git and GitHub is one of the most practical skills you can add to your DH toolkit.",
        "whatToDo": [
          "Read why DH projects benefit from version control",
          "In the terminal, type **next** to continue"
        ]
      },
      "git-1": {
        "title": "What is Git?",
        "description": "Git is a free, open-source tool that does version control on your computer. It was created to manage the Linux kernel source code and is now used worldwide. Git runs locally: it keeps the full history of your project in a hidden folder (a repository) inside your project. You don't need the internet to make commits—only when you want to share or back up with a server like GitHub. In this course we simulate Git in the terminal on this page—no installation needed.",
        "whyImportant": "Git is the standard for version control in software and in many DH projects. Understanding that Git is local-first (your history lives on your machine) helps you see why we later add GitHub for backup and collaboration.",
        "whatToDo": [
          "In the terminal on the right, type: **git --version**",
          "You'll see a simulated version. (On a real computer you'd install from https://git-scm.com/.)",
          "Type **next** when ready to continue"
        ],
        "codeTemplate": "git --version"
      },
      "git-2": {
        "title": "Your first repository: git init",
        "description": "A repository (or repo) is the folder where Git keeps the history of your project. To turn a folder into a Git repository, you run git init in that folder. Here, the terminal is already in a simulated project folder (~/my-project). After git init, Git will track changes to files when you tell it to.",
        "whyImportant": "Creating a repo is the first step to using Git. From here on, we'll add files and make commits inside this repo—all in the browser terminal.",
        "whatToDo": [
          "In the terminal, type: **git init**",
          "You should see \"Initialized empty Git repository in .git/\"",
          "The lesson completes automatically when you run the command"
        ],
        "codeTemplate": "git init"
      },
      "git-3": {
        "title": "Staging and committing: git add and git commit",
        "description": "Git doesn't save every change automatically. You choose which changes to include in a \"commit\" (a snapshot). First you stage the files with git add, then you create the snapshot with git commit -m \"Your message\". You can create or edit files right here: use **echo \"text\" > filename** or **edit filename**. To edit a file in this simulation: type **edit** followed by the filename in the terminal; the editor opens below—make your changes and click Save. Then run git add and git commit in the terminal.",
        "whyImportant": "Commits are the building blocks of your history. Good commit messages help you and others understand the project later—especially important in DH when you need to cite or explain a specific version.",
        "whatToDo": [
          "In the terminal: create or edit a file (e.g. **echo \"Hello\" > readme.txt** or **edit readme.txt** and save). To edit a file: type **edit filename** in the terminal; the editor opens below—click Save when done.",
          "Then type: **git add .** (or **git add readme.txt**)",
          "Then: **git commit -m \"First commit\"** (use any short message)",
          "The lesson completes when you make a commit"
        ],
        "codeTemplate": "git add .\ngit commit -m \"Your short message\""
      },
      "git-4": {
        "title": "Checking status: git status",
        "description": "At any time you can run git status to see which files are modified, which are staged for the next commit, and which are untracked. This helps you stay in control before committing. Try editing a file (echo or edit) and run git status again to see the change. To edit a file here: type **edit filename** in the terminal; the editor opens below—then click Save.",
        "whyImportant": "Using git status regularly avoids committing the wrong files or forgetting to add something. It's a habit that will save you in real projects.",
        "whatToDo": [
          "In the terminal, type: **git status**",
          "Optionally change a file (**echo \"more\" >> readme.txt** or **edit readme.txt**) and run **git status** again (to edit: type **edit readme.txt** in the terminal; the editor opens below—click Save)",
          "Type **next** when done"
        ],
        "codeTemplate": "git status"
      },
      "git-5": {
        "title": "Ignoring files: .gitignore",
        "description": "Some files should never be committed: secrets, build outputs, or local config. A **.gitignore** file lists patterns (one per line). Git then ignores those files: they won't appear as untracked in **git status** and won't be added with **git add .**. You can create **.gitignore** with **edit .gitignore** and add a line like **secret.txt** or ***.log**. To edit a file here: type **edit .gitignore** in the terminal; the editor opens below—add your lines and click Save. Then create a file matching that pattern and run **git status**—the ignored file won't be listed. Commit the **.gitignore** file itself so the rules are shared with others.",
        "whyImportant": "Without .gitignore you might commit passwords, API keys, or thousands of generated files. In DH projects you often ignore data caches, local config, and editor backups.",
        "whatToDo": [
          "Create a **.gitignore** file (e.g. **edit .gitignore** and add a line: **secret.txt**). Type **edit .gitignore** in the terminal; the editor opens below—add **secret.txt** and click Save.",
          "Optionally create a file that matches (e.g. **echo \"don't commit\" > secret.txt**)",
          "Run **git status**—you should see **.gitignore** as untracked but not the ignored file",
          "Run **git add .gitignore** and **git commit -m \"Add .gitignore\"** to finish the lesson"
        ],
        "codeTemplate": "edit .gitignore\n# add line: secret.txt\ngit add .gitignore\ngit commit -m \"Add .gitignore\""
      },
      "git-6": {
        "title": "Fixing mistakes: unstage, discard, amend",
        "description": "You can fix common slip-ups without losing work. **git restore --staged <file>** unstage a file (remove it from the next commit). **git restore <file>** discards uncommitted changes in that file—it reverts the file to the last committed version (use with care). **git commit --amend -m \"New message\"** replaces the last commit: either change the message or add more staged changes into that commit. Here you have one commit; try unstaging a file, discarding changes, or amending the last commit.",
        "whyImportant": "Everyone stages the wrong file or commits with a typo. Knowing how to unstage, discard, or amend keeps your history clean and avoids embarrassing pushes.",
        "whatToDo": [
          "**Unstage:** Change **readme.txt** (type **edit readme.txt** in the terminal; the editor opens below—edit and click Save), run **git add readme.txt**, then **git restore --staged readme.txt**. Run **git status** to see it's no longer staged.",
          "**Discard changes:** Change **readme.txt** again (**edit readme.txt** in the terminal, then Save), then **git restore readme.txt**. The file is back to the last committed version.",
          "**Amend:** Make a small change, **git add** and **git commit -m \"Typo\"**, then **git commit --amend -m \"Fixed typo\"** to replace the last commit message.",
          "Type **next** when you've tried at least one of these"
        ],
        "codeTemplate": "git add readme.txt\ngit restore --staged readme.txt\ngit status"
      },
      "branch-1": {
        "title": "Branching: create and switch branches",
        "description": "Branches let you work on a separate line of development without affecting the main branch. Each branch can have its own version of files. Use **git branch** to list branches (the current one has a *). Create a new branch with **git checkout -b <name>** (this creates and switches to it). Use **git checkout <name>** to switch to an existing branch—your working directory updates to match that branch's files. In this lesson you'll change **readme.txt** differently on each branch, then use **cat readme.txt** to see that the file content is different on each branch.",
        "whyImportant": "Branching is essential for trying out changes, working on features separately, and collaborating. In DH projects you might use a branch for a new edition variant or a dataset update.",
        "whatToDo": [
          "Run **git branch** to see the current branch (main)",
          "Create a new branch: **git checkout -b feature** (or any name)",
          "Change **readme.txt** on this branch (e.g. **echo \"Feature version\" > readme.txt** or **edit readme.txt**). To edit: type **edit readme.txt** in the terminal; the editor opens below—click Save. Then **git add readme.txt** and **git commit -m \"Feature content\"**",
          "Switch to main: **git checkout main**. Run **cat readme.txt** to see main's version of the file",
          "Change **readme.txt** on main to something different (e.g. **echo \"Main version\" > readme.txt** or **edit readme.txt**—type **edit readme.txt** in the terminal, edit in the panel below, then Save). Then **git add readme.txt** and **git commit -m \"Main content\"**",
          "Run **cat readme.txt** again—you'll see the main version. Then **git checkout feature** and run **cat readme.txt**—you'll see the feature version. Each branch has its own copy.",
          "Type **next** when done"
        ],
        "codeTemplate": "git checkout -b feature\necho \"Feature version\" > readme.txt\ngit add readme.txt\ngit commit -m \"Feature content\"\ngit checkout main\ncat readme.txt"
      },
      "branch-2": {
        "title": "Merging branches",
        "description": "When you're happy with work on a branch, you merge it into another (usually main) with **git merge <branch>**. Git combines the histories. If the other branch has new commits since you branched, you may get a merge commit; if not, Git does a \"fast-forward\" (no merge commit). After merging, the current branch includes the other branch's commits. Once a branch is merged, you can delete it locally with **git branch -d <name>** to keep your branch list tidy; the commits remain in the history of the branch you merged into.",
        "whyImportant": "Merging is how you bring feature work back into the main line. Understanding merge vs. fast-forward helps you keep history clear. Deleting merged branches avoids clutter and makes it obvious which branches are still in progress.",
        "whatToDo": [
          "Create a branch and make a commit on it (e.g. **git checkout -b feature**, edit a file—type **edit readme.txt** in the terminal, change the content in the editor below and click Save—then **git add .**, **git commit -m \"Add feature\"**)",
          "Switch to main: **git checkout main**",
          "Merge the branch: **git merge feature**",
          "Optionally delete the merged branch: **git branch -d feature** (keeps your branch list tidy)",
          "Run **git log** to see the merged history. Type **next** when done"
        ],
        "codeTemplate": "git checkout -b feature\ngit add .\ngit commit -m \"Add feature\"\ngit checkout main\ngit merge feature\ngit branch -d feature"
      },
      "branch-3": {
        "title": "Squash merging",
        "description": "A **squash merge** (**git merge --squash <branch>**) brings the other branch's changes into your working tree as a single set of staged changes, without creating a merge commit. You then commit once—so multiple commits on the other branch become one commit on the current branch. Useful for keeping history tidy.",
        "whyImportant": "Squashing turns a messy series of \"WIP\" or \"fix typo\" commits into one clear commit, which is easier to review and cite.",
        "whatToDo": [
          "You start on a branch (**feature**) that already has multiple commits. Switch to main: **git checkout main**",
          "Run **git merge --squash feature**",
          "Run **git status**—you'll see the changes staged. Then **git commit -m \"Add feature (squashed)\"** to complete",
          "*(Optional)* Delete the branch now that it's merged: **git branch -d feature**",
          "Type **next** when done"
        ],
        "codeTemplate": "git checkout main\ngit merge --squash feature\ngit commit -m \"Add feature (squashed)\"\ngit branch -d feature"
      },
      "branch-4": {
        "title": "Rebasing",
        "description": "**git rebase <branch>** moves your current branch's commits so they sit on top of the other branch. The result is a linear history: first the other branch's commits, then yours replayed. Use it to update a feature branch with the latest main, or to clean up history before merging.",
        "whyImportant": "Rebasing keeps history linear and avoids unnecessary merge commits. In DH projects it can make the evolution of a text or dataset easier to follow.",
        "whatToDo": [
          "Start from main with at least one commit. Create a branch and commit on it",
          "On the feature branch, run **git rebase main** (or rebase onto the branch you want to base on)",
          "Your branch's commits are now replayed on top of main. Use **git log** to see the linear history",
          "Type **next** when done"
        ],
        "codeTemplate": "git checkout -b feature\ngit commit -m \"Change\"\ngit rebase main"
      },
      "branch-5": {
        "title": "Merge conflicts",
        "description": "When two branches change the **same part** of the same file, Git cannot merge automatically. You get a **merge conflict**: the file is marked with conflict markers (**<<<<<<<**, **=======**, **>>>>>>>**) showing the two versions. To resolve it: open the file, decide what the final content should be (keep one version, combine both, or edit by hand), remove the conflict markers and the version you don't want, then **git add** the file and **git commit** to complete the merge. In this simulation, to open a file for editing: type **edit filename** in the terminal; the editor opens below—edit the content and click Save. Conflicts are normal when several people edit the same lines; resolving them is a routine part of collaboration.",
        "whyImportant": "In DH projects, multiple editors or datasets can touch the same files. Knowing how to read conflict markers and resolve conflicts lets you merge branches and pull others' work without fear.",
        "whatToDo": [
          "**readme.txt** already has a conflict. Run **cat readme.txt** to see the conflict markers",
          "Type **edit readme.txt** in the terminal—the editor opens below. Remove the conflict markers and keep the content you want (one version, the other, or a combination). Click **Save**",
          "Stage the resolved file: **git add readme.txt**",
          "Complete the merge: **git commit -m \"Resolve conflict\"**",
          "Type **next** when done"
        ],
        "codeTemplate": "cat readme.txt\nedit readme.txt\ngit add readme.txt\ngit commit -m \"Resolve conflict\""
      },
      "gh-1": {
        "title": "What is GitHub?",
        "description": "GitHub is a website that hosts Git repositories in the cloud. It gives you a backup of your repo, a visible history online, and tools for collaboration: others can clone your repo, suggest changes (pull requests), and you can manage issues and documentation. GitHub is very common in open source and in DH.",
        "whyImportant": "Git is local; GitHub is remote. Together they let you back up your work, share it, and collaborate. Many DH projects publish their data and code on GitHub for transparency and reuse.",
        "whatToDo": [
          "Read the section above. (You can sign up at https://github.com on your own computer later.)",
          "In the terminal, type **next** when ready to continue"
        ]
      },
      "gh-2": {
        "title": "Creating a repository on GitHub",
        "description": "On GitHub, you'd click \"New repository\", choose a name (e.g. my-dh-project), and get a URL to connect your local repo. In a real workflow you create this repo first, then use its URL in git remote and git push. You can try this on github.com later; for this lesson we focus on the idea.",
        "whyImportant": "The remote repo on GitHub is the place your local history will be copied to when you push. Creating it first gives you the URL you need for the next step.",
        "whatToDo": [
          "Read the steps above (you can create a real repo on GitHub later from your computer)",
          "In the terminal, type **next** when done"
        ]
      },
      "gh-3": {
        "title": "Pushing your code: git remote and git push",
        "description": "To send your local commits to GitHub, you link your repo to the remote with git remote add origin <URL>, then push with git push -u origin main. Here you can run these commands in the terminal (use any URL for the simulation); the lesson completes when you run git remote add or git push.",
        "whyImportant": "Pushing is how you back up and share your work. Once set up, it becomes a simple step in your workflow.",
        "whatToDo": [
          "In the terminal: **git remote add origin https://github.com/you/repo.git** (any URL is fine for this simulation)",
          "Then: **git push -u origin main**",
          "The lesson completes when you run the commands"
        ],
        "codeTemplate": "git remote add origin https://github.com/USER/REPO.git\ngit push -u origin main"
      },
      "gh-4": {
        "title": "Getting a copy: git clone and git pull",
        "description": "To get a full copy of someone else's repo (or your own from another computer), you'd use git clone <URL>. When you clone, Git creates a new folder (usually named after the repo) and puts the full copy there—so the cloned repo always lives in its own directory. To update an existing copy, you run git pull. Here you can try these commands in the terminal—e.g. **git clone https://github.com/some/repo** or **git pull**—to see the simulated output.",
        "whyImportant": "Clone and pull are how you work with existing DH projects, contribute to others' work, or sync between machines. They're essential for collaboration.",
        "whatToDo": [
          "In the terminal, try **git clone https://github.com/some/repo** or **git pull**",
          "Type **next** when done"
        ],
        "codeTemplate": "git clone https://github.com/USER/REPO.git\ngit pull"
      },
      "collab-1": {
        "title": "Collaboration and good practices for DH",
        "description": "In practice, DH teams use branches (separate lines of work) and pull requests (proposed changes for review) on GitHub. Commit often with clear messages; push regularly so work is backed up. Use a README to explain the project and, if relevant, a license so others know how they can reuse your data and code. These practices make your project understandable and citable.",
        "whyImportant": "Good version control habits make DH projects reproducible, transparent, and easier to hand off or publish. They align with open scholarship and funder expectations.",
        "whatToDo": [
          "Read the collaboration and good-practice tips above",
          "In the terminal, type **next** to continue"
        ]
      },
      "collab-2": {
        "title": "Next steps: install Git, GitHub, and authentication",
        "description": "This tutorial runs in the browser. To use Git and GitHub on your own computer: (1) **Install Git** from https://git-scm.com/ (or your package manager). (2) **Create a GitHub account** at https://github.com if you don't have one. (3) **Set up authentication** so you can push and pull: either **SSH keys** (recommended) or a **personal access token** over HTTPS. GitHub's docs explain both: \"Connecting to GitHub with SSH\" and \"Managing your personal access tokens.\" Once Git is installed and authentication is set up, you can clone repos, push your work, and open pull requests from the command line or a GUI.",
        "whyImportant": "Without these steps, commands like git push will ask for credentials or fail. A few minutes of setup on your machine unlock everything you've learned here.",
        "whatToDo": [
          "Read the steps above and bookmark the links",
          "When you're ready, type **next** to finish the course and view your certificate"
        ]
      }
    },
    "glossary": {
      "version control": "A system that records changes to files over time so you can recall or compare specific versions later.",
      "repository": "A folder managed by Git, containing the project files and the full history of commits.",
      "repo": "Short for repository: the folder where Git keeps your project's history.",
      "commit": "A snapshot of your project at a point in time, with a message and a unique ID. Commits form the history of the project.",
      "stage": "To mark files as ready to be included in the next commit (using git add).",
      "staged": "Marked as ready to be included in the next commit (using git add).",
      "push": "To send your local commits to a remote repository (e.g. on GitHub).",
      "pull": "To fetch and merge changes from a remote repository into your current branch.",
      "clone": "To download a copy of a repository (including its history) from a remote server.",
      "clones": "Copies of a repository (including its full history) downloaded from a remote server. You might clone once per machine or per working copy.",
      "remote": "A version of the repository hosted elsewhere (e.g. on GitHub), often named origin.",
      "remotes": "Versions of the repository hosted elsewhere (e.g. on GitHub). A repo can have multiple remotes; the default is often named origin.",
      "origin": "The default name for the remote repository (usually on GitHub) that your local repo is linked to.",
      "Git": "A free, open-source tool for version control on your computer. It keeps the full history of your project in a repository and works locally; you only need the internet to share or back up (e.g. via GitHub).",
      "GitHub": "A web platform that hosts Git repositories and provides tools for collaboration, issues, and documentation.",
      "Digital Humanities": "Research and teaching that combine computational methods with humanities disciplines; often involves texts, datasets, and code that benefit from version control.",
      "DH": "Abbreviation for Digital Humanities.",
      "branch": "A separate line of development in a Git repository. You can create branches to try changes or work on features without affecting the main line.",
      "branches": "Separate lines of development in a Git repository. You can create branches to try changes or work on features without affecting the main line.",
      "merge": "To combine the commits from another branch into your current branch (e.g. git merge feature).",
      "merge conflict": "When two branches modify the same part of the same file, Git cannot merge automatically. The file is marked with conflict markers (<<<<<<<, =======, >>>>>>>); you edit the file to choose the final content, remove the markers, then git add and git commit to complete the merge.",
      "merge commit": "A commit that records the merging of two branches when they have diverged (no fast-forward).",
      "fast-forward": "When merging, if the current branch has not diverged, Git simply moves the branch pointer forward; no merge commit is created.",
      "squash merge": "A merge that brings another branch's changes as a single set of staged changes, without a merge commit. You then make one commit, so multiple commits become one.",
      "rebase": "To move your branch's commits so they sit on top of another branch, producing a linear history. Use git rebase <branch>.",
      "pull request": "On GitHub, a proposal to merge changes from one branch into another, for review and discussion before merging.",
      "README": "A file (usually README.md) that explains a project: what it is, how to use it, and how to contribute. Often displayed on GitHub.",
      "untracked": "A file that Git is not yet tracking (not in the last snapshot and not staged). git status lists untracked files.",
      ".gitignore": "A file in the root of your repo that lists patterns (one per line). Git ignores matching files: they won't show as untracked and won't be added with git add .",
      "amend": "To change the last commit. git commit --amend -m \"New message\" replaces the message; with staged changes, it folds them into that commit.",
      "snapshot": "A point-in-time copy of your project. In Git, each commit is a snapshot of the tracked files.",
      "main": "The default branch name in many Git repositories. The primary line of development; feature branches are often merged back into main.",
      "working tree": "The directory containing your project files as they appear on disk. Changes you make exist in the working tree until you stage and commit them.",
      "conflict markers": "The symbols Git inserts into a file during a merge conflict: <<<<<<<, =======, >>>>>>>. You remove them when resolving the conflict.",
      "checkout": "To switch to another branch (e.g. git checkout main) or to restore a file. git checkout -b <name> creates and switches to a new branch.",
      "upstream": "The remote branch that your current branch tracks. Setting it (e.g. with git push -u origin main) links your branch to the remote.",
      "license": "A file or notice that states how others may use, share, or modify your project's code and data.",
      "modified": "A file that has been changed since the last commit. git status lists modified files (and whether they are staged or not).",
      "unstage": "To remove a file from the staging area so it will not be included in the next commit (e.g. git restore --staged <file>).",
      "open source": "Software or projects whose source code (or data) is made available for use, modification, and sharing, often under a license.",
      "issues": "On GitHub, a way to track tasks, bugs, and discussions for a repository. Others can open issues to suggest changes or report problems.",
      "authentication": "The process of proving your identity to GitHub so you can push and pull. Common methods: SSH keys (recommended) or a personal access token over HTTPS.",
      "SSH keys": "A secure way to authenticate with GitHub without typing a password each time. You generate a key pair on your computer and add the public key to your GitHub account.",
      "personal access token": "A password-like credential for HTTPS that lets you push and pull from GitHub. You create it in GitHub settings and use it instead of your account password.",
      "staging area": "The place where Git keeps the files you've added with git add, ready for the next commit. Also called the index. git status shows what is staged.",
      "history": "The sequence of commits in a repository. git log shows the history; each commit points to its parent(s).",
      "local": "On your own computer. A local repository is the copy on your machine; local commits are those not yet pushed to a remote.",
      "tracked": "A file that Git is tracking—it was in the last commit or has been added with git add. Untracked files are not yet in the repository.",
      "commit message": "The short description you give when committing (e.g. with -m \"Your message\"). Good messages help you and others understand the history later.",
      "workflow": "The way you use Git day to day: edit files, git add, git commit, and (when sharing) git push or git pull.",
      "resolve": "To fix a merge conflict by editing the file, choosing the final content, removing conflict markers, then staging and committing.",
      "reproducibility": "The ability for others (or future you) to recreate or cite a specific state of a project. Version control supports reproducibility.",
      "transparency": "Making the history of changes visible and traceable. Funders and publishers often expect version control for transparency.",
      ".git": "The hidden folder inside your project where Git stores the repository (all commits, branches, and metadata). Created by git init.",
      "feature branch": "A branch used to develop a single feature or change, often merged back into main when done. Keeps main stable.",
      "diverged": "When two branches have different commits—e.g. you made commits on main while someone else made commits on another branch. Merging may create a merge commit.",
      "discard": "To throw away uncommitted changes in a file (e.g. git restore <file>). The file returns to the last committed version. Use with care.",
      "linear history": "A history where commits follow a single line, with no merge commits. Rebase can produce a linear history."
    },
    "cheatsheet": {
      "sections": [
        {
          "title": "1. Version control",
          "paragraphs": [
            "What it is: A way to save and track changes to your files over time. One project, one history of every change: who changed what, and when. You can go back to any earlier version.",
            "Why it matters: Without it, you can lose work, overwrite others' changes, or forget what you changed. With it, you have a clear history and can collaborate safely.",
            "For Digital Humanities: Editions, corpora, datasets, and websites often involve teams, years of iteration, and the need to cite or reproduce a specific state. Many funders and publishers expect or recommend version control for transparency and reproducibility."
          ]
        },
        {
          "title": "2. Git basics",
          "subsections": [
            {
              "title": "What is Git?",
              "list": [
                "Free, open-source tool for version control on your computer.",
                "Runs locally: full history lives in a hidden folder (a repository) inside your project.",
                "No internet needed to make commits—only when you share or back up (e.g. with GitHub)."
              ]
            },
            {
              "title": "Essential commands",
              "items": [
                { "cmd": "git init", "desc": "Turn the current folder into a Git repository" },
                { "cmd": "git add <file> or git add .", "desc": "Stage files for the next commit" },
                { "cmd": "git commit -m \"Your message\"", "desc": "Create a snapshot with a short message" },
                { "cmd": "git status", "desc": "See modified, staged, and untracked files" },
                { "cmd": "git log", "desc": "View commit history" },
                { "cmd": "git log --oneline", "desc": "Compact one-line view of history" }
              ]
            },
            {
              "title": "Workflow",
              "list": [
                "Create or edit files.",
                "git add the files you want to include.",
                "git commit -m \"Clear, short message\".",
                "Use git status often to avoid committing the wrong files."
              ]
            },
            {
              "title": ".gitignore",
              "list": [
                "A file that lists patterns (one per line). Git ignores matching files: they won't show as untracked and won't be added with git add .",
                "Use it for: secrets, API keys, build outputs, local config, caches, editor backups.",
                "Create with: edit .gitignore (in the tutorial) or any text editor. Commit .gitignore so the rules are shared."
              ]
            },
            {
              "title": "Fixing mistakes",
              "items": [
                { "cmd": "git restore --staged <file>", "desc": "Unstage a file (remove from the next commit)" },
                { "cmd": "git restore <file>", "desc": "Discard uncommitted changes in that file (use with care)" },
                { "cmd": "git commit --amend -m \"New message\"", "desc": "Replace the last commit's message (or add more staged changes into it)" },
                { "cmd": "git reset --soft HEAD~1", "desc": "Undo last commit but keep changes staged" }
              ]
            }
          ]
        },
        {
          "title": "3. Branching",
          "paragraphs": [
            "Branch: A separate line of development. You can try changes or work on features without affecting the main line.",
            "Why: Essential for trying ideas, working on features separately, and collaborating. In DH you might use a branch for a new edition variant or dataset update."
          ],
          "subsections": [
            {
              "title": "Commands",
              "items": [
                { "cmd": "git branch", "desc": "List branches (* = current)" },
                { "cmd": "git checkout -b <name>", "desc": "Create and switch to a new branch" },
                { "cmd": "git checkout <name>", "desc": "Switch to an existing branch" },
                { "cmd": "git merge <branch>", "desc": "Merge that branch into the current branch" },
                { "cmd": "git merge --squash <branch>", "desc": "Bring the other branch's changes as one set of staged changes; you then commit once (no merge commit)" },
                { "cmd": "git rebase <branch>", "desc": "Move your commits so they sit on top of the other branch (linear history)" },
                { "cmd": "git branch -d <name>", "desc": "Delete a merged branch (keeps the list tidy)" }
              ]
            },
            {
              "title": "Merge conflicts",
              "list": [
                "When two branches change the same part of the same file, Git cannot merge automatically.",
                "The file is marked with conflict markers: <<<<<<<, =======, >>>>>>>.",
                "Resolve: Open the file, choose the final content (keep one version, combine, or edit), remove the markers and the version you don't want, then git add the file and git commit."
              ]
            }
          ]
        },
        {
          "title": "4. GitHub",
          "paragraphs": [
            "What it is: A website that hosts Git repositories in the cloud. Backup, visible history, and tools for collaboration: others can clone, suggest changes (pull requests), and you can manage issues and documentation.",
            "Relation: Git is local; GitHub is remote. Together they let you back up, share, and collaborate."
          ],
          "subsections": [
            {
              "title": "Creating a repo on GitHub",
              "list": [
                "On GitHub: New repository → choose a name (e.g. my-dh-project) → you get a URL to connect your local repo."
              ]
            },
            {
              "title": "Remote and push/pull",
              "items": [
                { "cmd": "git remote add origin <URL>", "desc": "Link your local repo to the remote (e.g. GitHub)" },
                { "cmd": "git push -u origin main", "desc": "First push: send commits and set upstream" },
                { "cmd": "git push", "desc": "Send your commits to the remote" },
                { "cmd": "git pull", "desc": "Fetch and merge changes from the remote" },
                { "cmd": "git clone <URL>", "desc": "Download a full copy of a repository (creates a new folder)" }
              ]
            },
            {
              "title": "Tip",
              "paragraphs": ["Run git pull before git push to avoid rejections when others have pushed."]
            }
          ]
        },
        {
          "title": "5. Collaboration and good practices",
          "list": [
            "Use branches for separate lines of work; use pull requests on GitHub to propose and review changes before merging.",
            "Commit often with clear, short messages.",
            "Push regularly so work is backed up.",
            "Add a README (e.g. README.md) to explain the project and how to use or contribute.",
            "Add a license so others know how they can reuse your data and code.",
            "One branch per feature or fix, then merge when ready."
          ]
        },
        {
          "title": "6. Command cheatsheet (quick reference)",
          "subsections": [
            { "title": "Setup", "code": "git config user.name \"Your Name\"\ngit config user.email \"your@email.com\"\ngit init" },
            { "title": "Basic workflow", "code": "git status\ngit add <file>    # or git add .\ngit commit -m \"message\"\ngit log" },
            { "title": "Branches", "code": "git branch\ngit checkout -b <branch>\ngit checkout <branch>\ngit merge <branch>\ngit merge --squash <branch>\ngit rebase <branch>\ngit branch -d <branch>" },
            { "title": "Remote (GitHub)", "code": "git remote add origin <URL>\ngit push -u origin main\ngit push\ngit pull\ngit clone <URL>" },
            { "title": "Useful", "code": "git log --oneline\ngit remote -v\ngit restore --staged <file>\ngit restore <file>\ngit commit --amend -m \"New message\"" }
          ]
        },
        {
          "title": "7. Key terms (glossary)",
          "items": [
            { "cmd": "Repository (repo)", "desc": "Folder managed by Git; contains project files and full commit history." },
            { "cmd": "Commit", "desc": "A snapshot of the project at a point in time, with a message and unique ID." },
            { "cmd": "Stage / staged", "desc": "Mark files as ready for the next commit with git add." },
            { "cmd": "Remote / origin", "desc": "The version of the repo hosted elsewhere (e.g. GitHub); origin is the default name." },
            { "cmd": "Push / Pull / Clone", "desc": "Push: send local commits to a remote. Pull: fetch and merge from remote. Clone: download a full copy of a repo." },
            { "cmd": "Branch / Merge", "desc": "Branch: separate line of development. Merge: combine another branch into the current one." },
            { "cmd": "Merge conflict", "desc": "Same part of same file changed in two branches; you resolve by editing the file and removing conflict markers." },
            { "cmd": "Untracked / .gitignore", "desc": "Untracked: file Git is not yet tracking. .gitignore: file listing patterns Git should ignore." }
          ]
        },
        {
          "title": "8. Next steps (on your own computer)",
          "list": [
            "Install Git: https://git-scm.com/ (or your package manager).",
            "Create a GitHub account: https://github.com",
            "Set up authentication so you can push and pull: SSH keys (recommended), or Personal access token over HTTPS. See GitHub docs: \"Connecting to GitHub with SSH\" and \"Managing your personal access tokens.\"",
            "Once Git is installed and authentication is set up, you can clone repos, push your work, and open pull requests from the command line or a GUI."
          ],
          "paragraphs": ["Tutorial: https://humanities-data-lab.github.io/learn-git-and-github/"]
        }
      ]
    }
  },
  "fr": {
    "ui": {
      "title": "Apprendre Git et GitHub",
      "subtitle": "Contrôle de version dès le début — Essentiel pour les humanités numériques",
      "welcome": "Bienvenue dans Git et GitHub !",
      "welcomeDescription": "Ce tutoriel interactif enseigne le contrôle de version depuis les bases. Aucune connaissance préalable de Git, GitHub ou du contrôle de version n'est requise. Vous verrez pourquoi ces outils sont importants—surtout pour les projets en humanités numériques—et comment les utiliser. Tout se fait dans le terminal et l'éditeur de fichiers sur cette page : pas besoin d'utiliser le terminal de votre ordinateur ni d'installer Git.",
      "tutorialCredit": "Réalisé par Asher Lacho en coordination avec le Humanities Data Lab. Ce tutoriel reprend le même système de modules que le cours HTML/CSS. Il est disponible en anglais et en français.",
      "enterName": "Entrez votre nom",
      "chooseAvatar": "Choisissez votre avatar",
      "chooseAvatarOption": "Option d'avatar {number} sur {total}",
      "avatarPickerScrollHint": "Faites défiler pour plus d'avatars",
      "changeAvatar": "Changer d'avatar",
      "createYourAvatar": "Créez votre avatar",
      "avatarSkinTone": "Teint",
      "avatarHairStyle": "Coiffure",
      "avatarHairColor": "Couleur des cheveux",
      "avatarClothingStyle": "Type de vêtement",
      "avatarClothingColor": "Couleur du vêtement",
      "avatarMouth": "Bouche",
      "avatarEyes": "Yeux",
      "avatarAccessories": "Lunettes et accessibilité",
      "avatarAccessoriesColor": "Couleur lunettes / accessoire",
      "avatarEyebrows": "Sourcils",
      "avatarFacialHair": "Barbe / moustache",
      "avatarFacialHairColor": "Couleur barbe",
      "avatarHatColor": "Couleur chapeau / coiffe",
      "avatarClothingGraphic": "Motif du T-shirt",
      "addColor": "Ajouter une couleur",
      "addColorHint": "Cliquez sur un carré pour changer la couleur ; ajoutez-en pour donner d'autres teintes à l'avatar.",
      "removeColor": "Retirer",
      "done": "Terminé",
      "randomizeAvatar": "Avatar aléatoire",
      "startLearning": "Commencer",
      "nameCertificateNote": "Ce nom apparaîtra sur votre certificat partageable à la fin de toutes les leçons.",
      "welcomeUser": "Bienvenue, {name} ! • Leçon {current} sur {total}",
      "courseProgress": "Progression — Cliquez sur une section pour y aller",
      "whatWeLearning": "Ce que nous apprenons :",
      "whyImportant": "Pourquoi c'est important :",
      "needHint": "Besoin d'un indice ? Cliquez pour voir quoi faire",
      "hideHint": "Masquer l'indice",
      "showHint": "Afficher l'indice",
      "whatToDo": "À faire :",
      "commandsToTry": "Commande(s) à essayer",
      "copyCommand": "Copier la commande",
      "terminalHint": "Utilisez le terminal à droite pour exécuter la commande.",
      "terminalNavHint": "Commandes : ls, pwd, cd, cat, echo, edit | git ... | next | back | clear",
      "editorLabel": "Éditeur de fichier",
      "save": "Enregistrer",
      "cancel": "Annuler",
      "back": "← Retour",
      "verifyCode": "C'est fait →",
      "skip": "Passer →",
      "tryAgain": "Réessayer",
      "nextLesson": "Leçon suivante →",
      "learnMore": "En savoir plus",
      "tip": "Conseil :",
      "copyUrl": "Copiez cette URL pour sauvegarder votre progression et reprendre plus tard :",
      "copyToClipboard": "Copier dans le presse-papiers",
      "copied": "Copié !",
      "noFilesSaved": "Aucune donnée n'est enregistrée sur notre serveur—c'est le seul moyen de retrouver votre progression.",
      "certificateTitle": "Certificat de réussite",
      "certificateSubtitle": "Git et GitHub pour le contrôle de version",
      "certificateDescription": "Ceci certifie que",
      "certificateCompleted": "a suivi avec succès le tutoriel sur le contrôle de version, les bases de Git et GitHub—en mettant l'accent sur leur importance pour les humanités numériques.",
      "certificateCovered": "Ce cours a couvert :",
      "completedOn": "Terminé le",
      "congratulations": "Félicitations",
      "certificateShare": "Partagez ce certificat en copiant l'URL :",
      "certificateShareDescription": "Vous pouvez copier l'URL ci-dessus pour partager votre certificat.",
      "printCertificate": "Imprimer le certificat",
      "emailCertificate": "Envoyer le certificat par courriel",
      "emailCertificateSubject": "Mon certificat Git et GitHub",
      "emailCertificateBody": "J'ai terminé le tutoriel Git et GitHub ! Voici mon certificat :",
      "certificateItem1": "Qu'est-ce que le contrôle de version et pourquoi il compte pour les humanités numériques",
      "certificateItem2": "Bases de Git : dépôts, commits et historique",
      "certificateItemBranching": "Branches : créer, fusionner, squash et rebase",
      "certificateItem3": "GitHub : hébergement, push, pull et clone",
      "certificateItem4": "Collaboration et bonnes pratiques pour les projets en HN",
      "successMessage": "Très bien ! Passez à la leçon suivante quand vous êtes prêt.",
      "errorMessage": "Pas tout à fait. Assurez-vous de : {elements}",
      "selectLanguage": "Choisir la langue",
      "studentNameAria": "Nom de l'étudiant : {name}",
      "completed": "Terminé",
      "jumpToSection": "Aller à la section {section}. {completed} sur {total} leçons terminées.",
      "hintRegion": "Instructions de l'indice",
      "glossaryButton": "Glossaire",
      "glossaryTitle": "Glossaire",
      "glossarySearchPlaceholder": "Rechercher un terme...",
      "glossaryClose": "Fermer le glossaire",
      "glossaryNoResults": "Aucun terme ne correspond.",
      "cheatsheetButton": "Aide-mémoire",
      "cheatsheetTitle": "Aide-mémoire Git et GitHub",
      "cheatsheetPrint": "Imprimer",
      "cheatsheetClose": "Fermer",
      "skipToMainContent": "Aller au contenu principal",
      "definitionOf": "Définition de {term}",
      "backToLessons": "Retour aux leçons",
      "viewCertificate": "Voir le certificat",
      "reportBug": "Signaler un bug",
      "branchVisualizerHelpButton": "Aide",
      "branchVisualizerHelpTitle": "À propos du graphe de branches",
      "branchVisualizerHelpBody": "Ce graphe affiche vos branches et commits Git. Chaque point est un commit (avec son hash court et son message). Les branches apparaissent en lignes séparées ; la branche main et toute branche que vous créez (ex. avec git checkout -b) sont affichées. Le libellé « current » indique la branche sur laquelle vous êtes. Les nouvelles branches apparaissent dès que vous les créez, même avant d'y faire un commit.",
      "lessonCompleteNext": "Leçon terminée ! Passage à la suivante...",
      "lessonCompleteTypeNext": "Leçon terminée ! Tapez \"next\" ou cliquez sur le bouton pour continuer.",
      "goingBackToLesson": "Retour à la leçon précédente.",
      "editUsage": "edit: usage: edit <filename>",
      "editingFile": "Édition de {filename} (enregistrer ou annuler dans l'éditeur ci-dessous)",
      "editFileReminder": "Pour modifier un fichier ici : tapez **edit** suivi du nom du fichier dans le terminal (ex. **edit readme.txt**) ; l'éditeur s'ouvre en dessous—faites vos modifications et cliquez sur Enregistrer.",
      "unsupportedGitCommand": "La commande que vous avez entrée peut être valide dans Git, mais l'environnement simulé de ce tutoriel ne la prend pas en charge—nous ne couvrons qu'un sous-ensemble de commandes ici."
    },
    "categories": {
      "tutorialIntro": "Comment fonctionne ce tutoriel",
      "versionControl": "Contrôle de version",
      "gitBasics": "Bases de Git",
      "branching": "Branches",
      "github": "GitHub",
      "collaboration": "Collaboration"
    },
    "lessons": {
      "intro-1": {
        "title": "Le terminal : ce qui fonctionne comme en réel",
        "description": "Ce tutoriel propose un **terminal simulé** à droite. La plupart du temps il se comporte comme un vrai terminal (Mac, Linux ou VS Code). Vous tapez des commandes et voyez la sortie ; l’invite affiche le dossier courant (**~/my-project**). Les commandes shell habituelles fonctionnent comme attendu : **ls** liste les fichiers, **pwd** affiche le répertoire courant, **cd** change de répertoire, **cat** affiche le contenu d’un fichier, et **echo** peut créer ou compléter un fichier (ex. **echo \"Bonjour\" > readme.txt**). La façon dont vous naviguez et exécutez des commandes est donc très proche d’un vrai terminal.",
        "whyImportant": "S’habituer à taper des commandes ici facilitera le passage à un vrai terminal ou à un IDE. Les réflexes que vous prenez (lire l’invite, utiliser ls et cat pour voir ce qu’il y a) sont les mêmes en réel.",
        "whatToDo": [
          "Lire l’explication ci-dessus",
          "Dans le terminal, essayez **ls** ou **pwd** pour voir qu’ils se comportent comme un shell normal",
          "Tapez **next** quand vous êtes prêt à continuer"
        ]
      },
      "intro-2": {
        "title": "Ce qu’on a simplifié : la commande edit et la simulation Git",
        "description": "Quelques éléments de ce tutoriel sont **simplifiés ou spécifiques** pour que vous puissiez apprendre sans rien installer. **Modifier des fichiers :** Dans un vrai terminal vous ouvririez un éditeur de texte (**nano**, **vim**, ou le fichier dans une app). Ici nous utilisons une commande intégrée **edit** : tapez **edit nomfichier** (ex. **edit readme.txt**) dans le terminal et un **panneau d’édition s’ouvre en dessous**—modifiez le contenu et cliquez sur **Enregistrer**. C’est propre à ce tutoriel. **Git :** Nous simulons Git dans le navigateur. Les commandes **git init**, **git add**, **git commit**, **git status**, **git branch**, **git merge**, **git remote**, **git push** et **git pull** se comportent comme en vrai et enseignent le vrai workflow. Mais il n’y a pas de vrai réseau : **git push** et **git pull** ne parlent pas à de vrais serveurs—les dépôts distants et les clones sont simulés. Vous n'avez pas besoin de comprendre cela pour l'instant—nous verrons les dépôts distants et les clones dans les leçons suivantes. Donc : la navigation et les commandes fichiers sont proches du réel ; **edit** est propre au tutoriel ; la logique Git est réelle, mais les remotes sont simulés.",
        "whyImportant": "Savoir ce qui est « réel » ou « pour cette leçon » vous aide à savoir à quoi vous attendre quand vous utiliserez Git et un terminal sur votre machine. Vous utiliserez un vrai éditeur et un vrai GitHub ; les notions apprises ici resteront valables.",
        "whatToDo": [
          "Lire l’explication ci-dessus",
          "Quand une leçon vous demande d’éditer un fichier, rappelez-vous : tapez **edit** suivi du nom du fichier indiqué dans la leçon (ex. **edit readme.txt**) dans le terminal, puis utilisez l’éditeur en dessous et cliquez sur Enregistrer",
          "Tapez **next** quand vous êtes prêt à commencer les leçons sur le contrôle de version"
        ]
      },
      "vc-1": {
        "title": "Qu'est-ce que le contrôle de version ?",
        "description": "Le contrôle de version permet de sauvegarder et de suivre l'évolution de vos fichiers dans le temps. Au lieu d'accumuler des fichiers comme \"these_v1.docx\", \"these_finale.docx\" et \"these_VRAIMENT_finale.docx\", vous gardez un seul projet et un historique de chaque modification : qui a changé quoi, et quand. Vous pouvez revenir à n'importe quelle version antérieure si besoin.",
        "whyImportant": "Sans contrôle de version, il est facile de perdre du travail, d'écraser les changements d'un collègue ou d'oublier ce qu'on a modifié. Avec lui, vous avez un historique clair et pouvez collaborer en toute sécurité. Pour les projets en humanités numériques—éditions, corpus, jeux de données, sites web—c'est essentiel : on travaille souvent en équipe, on itère sur des années, et on doit pouvoir citer ou reproduire un état précis du projet.",
        "whatToDo": [
          "Lire l'explication ci-dessus",
          "Penser à un projet (ex. une édition de texte ou un jeu de données) où vous voudriez suivre chaque changement",
          "Dans le terminal à droite, taper **next** quand vous êtes prêt à continuer"
        ]
      },
      "vc-2": {
        "title": "Pourquoi le contrôle de version compte pour les humanités numériques",
        "description": "Les projets en humanités numériques mêlent souvent textes, métadonnées, code et plusieurs personnes. Le contrôle de version permet : d'avoir une seule source de vérité au lieu de copies éparpillées ; de voir qui a ajouté ou modifié quelle ligne ; de revenir en arrière en cas d'erreur ; et de permettre à d'autres (ou à vous plus tard) de comprendre et reproduire votre travail. Beaucoup de financeurs et d'éditeurs attendent ou recommandent désormais le contrôle de version pour la transparence et la reproductibilité.",
        "whyImportant": "Le travail en HN est de la recherche. Pouvoir montrer comment un corpus ou une édition a évolué, et restaurer ou citer une version donnée, sert à la fois la pratique savante et la science ouverte. Apprendre Git et GitHub est l'une des compétences les plus utiles à ajouter à votre boîte à outils HN.",
        "whatToDo": [
          "Lire pourquoi les projets HN bénéficient du contrôle de version",
          "Dans le terminal, taper **next** pour continuer"
        ]
      },
      "git-1": {
        "title": "Qu'est-ce que Git ?",
        "description": "Git est un outil gratuit et open source qui fait du contrôle de version sur votre ordinateur. Créé pour gérer le code source du noyau Linux, il est utilisé partout dans le monde. Git fonctionne en local : il conserve tout l'historique de votre projet dans un dossier caché (un dépôt) à l'intérieur du projet. Vous n'avez pas besoin d'internet pour faire des commits—seulement quand vous voulez partager ou sauvegarder sur un serveur comme GitHub. Dans ce cours nous simulons Git dans le terminal sur cette page—aucune installation requise.",
        "whyImportant": "Git est le standard du contrôle de version en logiciel et dans beaucoup de projets HN. Comprendre qu'il est « local d'abord » (votre historique est sur votre machine) aide à voir pourquoi on ajoute ensuite GitHub pour la sauvegarde et la collaboration.",
        "whatToDo": [
          "Dans le terminal à droite, taper : **git --version**",
          "Vous verrez une version simulée. (Sur un vrai ordinateur vous l'installeriez depuis https://git-scm.com/.)",
          "Taper **next** quand vous êtes prêt à continuer"
        ],
        "codeTemplate": "git --version"
      },
      "git-2": {
        "title": "Votre premier dépôt : git init",
        "description": "Un dépôt (repository) est le dossier où Git conserve l'historique du projet. Pour transformer un dossier en dépôt Git, on lance git init dans ce dossier. Ici, le terminal est déjà dans un dossier projet simulé (~/my-project). Après git init, Git suivra les changements des fichiers quand vous le lui demanderez.",
        "whyImportant": "Créer un dépôt est la première étape pour utiliser Git. Ensuite nous ajouterons des fichiers et ferons des commits dans ce dépôt—tout dans le terminal du navigateur.",
        "whatToDo": [
          "Dans le terminal, taper : **git init**",
          "Vous devriez voir « Initialized empty Git repository in .git/ »",
          "La leçon se valide automatiquement quand vous exécutez la commande"
        ],
        "codeTemplate": "git init"
      },
      "git-3": {
        "title": "Mise en stage et commit : git add et git commit",
        "description": "Git ne sauvegarde pas chaque changement automatiquement. Vous choisissez quels changements inclure dans un « commit » (une photo du projet). D'abord vous mettez les fichiers en stage avec git add, puis vous créez la photo avec git commit -m \"Votre message\". Vous pouvez créer ou modifier des fichiers ici : utilisez **echo \"texte\" > nomfichier** ou **edit nomfichier**. Pour modifier un fichier dans cette simulation : tapez **edit** suivi du nom du fichier dans le terminal ; l'éditeur s'ouvre en dessous—faites vos modifications et cliquez sur Enregistrer. Puis lancez git add et git commit dans le terminal.",
        "whyImportant": "Les commits sont les briques de votre historique. De bons messages de commit aident vous et les autres à comprendre le projet plus tard—surtout en HN quand il faut citer ou expliquer une version précise.",
        "whatToDo": [
          "Dans le terminal : créer ou modifier un fichier (ex. **echo \"Bonjour\" > readme.txt** ou **edit readme.txt** puis enregistrer). Pour modifier un fichier : tapez **edit nomfichier** dans le terminal ; l'éditeur s'ouvre en dessous—cliquez sur Enregistrer quand c'est fait.",
          "Puis taper : **git add .** (ou **git add readme.txt**)",
          "Puis : **git commit -m \"Premier commit\"** (un message court)",
          "La leçon se valide quand vous faites un commit"
        ],
        "codeTemplate": "git add .\ngit commit -m \"Votre message court\""
      },
      "git-4": {
        "title": "Vérifier l'état : git status",
        "description": "À tout moment vous pouvez lancer git status pour voir quels fichiers sont modifiés, lesquels sont en stage pour le prochain commit, et lesquels ne sont pas suivis. Essayez de modifier un fichier (echo ou edit) et relancez git status pour voir le changement. Pour modifier un fichier ici : tapez **edit nomfichier** dans le terminal ; l'éditeur s'ouvre en dessous—puis cliquez sur Enregistrer.",
        "whyImportant": "Utiliser git status régulièrement évite de committer les mauvais fichiers ou d'oublier d'ajouter quelque chose. C'est une habitude qui vous servira dans les vrais projets.",
        "whatToDo": [
          "Dans le terminal, taper : **git status**",
          "Optionnel : modifier un fichier (**echo \"suite\" >> readme.txt** ou **edit readme.txt**) puis **git status** (pour éditer : tapez **edit readme.txt** dans le terminal ; l'éditeur s'ouvre en dessous—cliquez sur Enregistrer)",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git status"
      },
      "git-5": {
        "title": "Ignorer des fichiers : .gitignore",
        "description": "Certains fichiers ne doivent jamais être commités : secrets, fichiers de build ou config locale. Un fichier **.gitignore** liste des motifs (un par ligne). Git ignore alors ces fichiers : ils n'apparaissent pas comme non suivis dans **git status** et ne sont pas ajoutés avec **git add .**. Vous pouvez créer **.gitignore** avec **edit .gitignore** et ajouter une ligne comme **secret.txt** ou ***.log**. Pour modifier un fichier ici : tapez **edit .gitignore** dans le terminal ; l'éditeur s'ouvre en dessous—ajoutez vos lignes et cliquez sur Enregistrer. Puis créez un fichier correspondant et lancez **git status**—le fichier ignoré n'apparaîtra pas. Commitez le fichier **.gitignore** lui-même pour partager les règles avec les autres.",
        "whyImportant": "Sans .gitignore vous pourriez commiter des mots de passe, clés API ou des milliers de fichiers générés. En HN on ignore souvent les caches de données, la config locale et les sauvegardes d'éditeur.",
        "whatToDo": [
          "Créer un fichier **.gitignore** (ex. **edit .gitignore** et ajouter une ligne : **secret.txt**). Tapez **edit .gitignore** dans le terminal ; l'éditeur s'ouvre en dessous—ajoutez **secret.txt** et cliquez sur Enregistrer.",
          "Optionnel : créer un fichier qui correspond (ex. **echo \"ne pas commiter\" > secret.txt**)",
          "Lancer **git status**—vous devriez voir **.gitignore** comme non suivi mais pas le fichier ignoré",
          "Lancer **git add .gitignore** et **git commit -m \"Add .gitignore\"** pour terminer la leçon"
        ],
        "codeTemplate": "edit .gitignore\n# ajouter la ligne : secret.txt\ngit add .gitignore\ngit commit -m \"Add .gitignore\""
      },
      "git-6": {
        "title": "Corriger les erreurs : unstage, annuler, amend",
        "description": "Vous pouvez corriger les erreurs courantes sans perdre votre travail. **git restore --staged <fichier>** retire un fichier du stage (l'enlève du prochain commit). **git restore <fichier>** annule les changements non commités dans ce fichier—il le ramène à la dernière version commitée (à utiliser avec précaution). **git commit --amend -m \"Nouveau message\"** remplace le dernier commit : soit pour changer le message, soit pour y intégrer des changements mis en stage. Ici vous avez un commit ; essayez de retirer un fichier du stage, d'annuler des changements, ou d'amender le dernier commit.",
        "whyImportant": "Tout le monde met en stage le mauvais fichier ou commite avec une typo. Savoir unstage, annuler ou amender garde l'historique propre et évite les push embarrassants.",
        "whatToDo": [
          "**Retirer du stage :** Modifiez **readme.txt** (tapez **edit readme.txt** dans le terminal ; l'éditeur s'ouvre en dessous—éditez et cliquez sur Enregistrer), lancez **git add readme.txt**, puis **git restore --staged readme.txt**. Lancez **git status** pour voir qu'il n'est plus en stage.",
          "**Annuler les changements :** Modifiez **readme.txt** à nouveau (**edit readme.txt** dans le terminal, puis Enregistrer), puis **git restore readme.txt**. Le fichier revient à la dernière version commitée.",
          "**Amender :** Faites un petit changement, **git add** et **git commit -m \"Typo\"**, puis **git commit --amend -m \"Fixed typo\"** pour remplacer le message du dernier commit.",
          "Taper **next** quand vous avez essayé au moins une de ces commandes"
        ],
        "codeTemplate": "git add readme.txt\ngit restore --staged readme.txt\ngit status"
      },
      "branch-1": {
        "title": "Branches : créer et changer de branche",
        "description": "Les branches permettent de travailler sur une ligne de développement séparée sans toucher à la branche principale. Chaque branche peut avoir sa propre version des fichiers. Utilisez **git branch** pour lister les branches (la courante a un *). Créez une branche avec **git checkout -b <nom>** (création et bascule). Utilisez **git checkout <nom>** pour passer à une branche existante—le répertoire de travail est mis à jour pour refléter les fichiers de cette branche. Dans cette leçon vous modifierez **readme.txt** différemment sur chaque branche, puis **cat readme.txt** pour constater que le contenu du fichier est différent sur chaque branche.",
        "whyImportant": "Les branches sont essentielles pour tester des changements, travailler sur des fonctionnalités à part et collaborer. En HN vous pouvez avoir une branche pour une variante d'édition ou une mise à jour de jeu de données.",
        "whatToDo": [
          "Lancer **git branch** pour voir la branche courante (main)",
          "Créer une branche : **git checkout -b feature** (ou un autre nom)",
          "Modifier **readme.txt** sur cette branche (ex. **echo \"Version feature\" > readme.txt** ou **edit readme.txt**). Pour éditer : tapez **edit readme.txt** dans le terminal ; l'éditeur s'ouvre en dessous—cliquez sur Enregistrer. Puis **git add readme.txt** et **git commit -m \"Contenu feature\"**",
          "Revenir sur main : **git checkout main**. Lancer **cat readme.txt** pour voir la version du fichier sur main",
          "Modifier **readme.txt** sur main avec un contenu différent (ex. **echo \"Version main\" > readme.txt** ou **edit readme.txt**—tapez **edit readme.txt** dans le terminal, éditez dans le panneau ci-dessous, puis Enregistrer). Puis **git add readme.txt** et **git commit -m \"Contenu main\"**",
          "Relancer **cat readme.txt**—vous verrez la version main. Puis **git checkout feature** et **cat readme.txt**—vous verrez la version feature. Chaque branche a sa propre copie.",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout -b feature\necho \"Version feature\" > readme.txt\ngit add readme.txt\ngit commit -m \"Contenu feature\"\ngit checkout main\ncat readme.txt"
      },
      "branch-2": {
        "title": "Fusionner des branches",
        "description": "Quand le travail sur une branche vous convient, vous la fusionnez dans une autre (souvent main) avec **git merge <branche>**. Git combine les historiques. Si l'autre branche a de nouveaux commits depuis la divergence, vous pouvez avoir un commit de merge ; sinon, Git fait un « fast-forward » (pas de commit de merge). Après la fusion, la branche courante contient les commits de l'autre. Une fois une branche fusionnée, vous pouvez la supprimer en local avec **git branch -d <nom>** pour garder la liste des branches lisible ; les commits restent dans l'historique de la branche dans laquelle vous avez fusionné.",
        "whyImportant": "La fusion permet de réintégrer le travail d'une branche dans la ligne principale. Comprendre merge vs. fast-forward aide à garder un historique clair. Supprimer les branches fusionnées évite l'encombrement et rend clair quelles branches sont encore en cours.",
        "whatToDo": [
          "Créer une branche et faire un commit (ex. **git checkout -b feature**, modifier un fichier—tapez **edit readme.txt** dans le terminal, modifiez le contenu dans l'éditeur ci-dessous et cliquez sur Enregistrer—puis **git add .**, **git commit -m \"Ajout feature\"**)",
          "Revenir sur main : **git checkout main**",
          "Fusionner : **git merge feature**",
          "Optionnel : supprimer la branche fusionnée : **git branch -d feature** (pour garder la liste des branches lisible)",
          "Lancer **git log** pour voir l'historique fusionné. Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout -b feature\ngit add .\ngit commit -m \"Ajout feature\"\ngit checkout main\ngit merge feature\ngit branch -d feature"
      },
      "branch-3": {
        "title": "Fusion squash",
        "description": "Une **fusion squash** (**git merge --squash <branche>**) apporte les changements de l'autre branche dans votre arbre de travail comme un seul ensemble de changements en stage, sans créer de commit de merge. Vous commitez ensuite une fois—plusieurs commits sur l'autre branche deviennent un seul commit sur la branche courante. Utile pour garder un historique propre.",
        "whyImportant": "Squasher transforme une série de commits « WIP » ou « typo » en un commit clair, plus facile à relire et citer.",
        "whatToDo": [
          "Vous débutez sur une branche (**feature**) qui a déjà plusieurs commits. Revenir sur main : **git checkout main**",
          "Lancer **git merge --squash feature**",
          "Lancer **git status**—vous verrez les changements en stage. Puis **git commit -m \"Feature squashed\"** pour terminer",
          "*(Optionnel)* Supprimer la branche maintenant qu'elle est fusionnée : **git branch -d feature**",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout main\ngit merge --squash feature\ngit commit -m \"Feature squashed\"\ngit branch -d feature"
      },
      "branch-4": {
        "title": "Rebase",
        "description": "**git rebase <branche>** déplace les commits de la branche courante pour qu'ils reposent sur l'autre branche. Le résultat est un historique linéaire : d'abord les commits de l'autre branche, puis les vôtres rejoués. Utilisez-le pour mettre à jour une branche feature avec le dernier main, ou pour nettoyer l'historique avant une fusion.",
        "whyImportant": "Le rebase garde un historique linéaire et évite les commits de merge inutiles. En HN cela peut rendre l'évolution d'un texte ou d'un jeu de données plus lisible.",
        "whatToDo": [
          "Partir de main avec au moins un commit. Créer une branche et committer dessus",
          "Sur la branche feature, lancer **git rebase main**",
          "Les commits de votre branche sont rejoués sur main. Utilisez **git log** pour voir l'historique linéaire",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git checkout -b feature\ngit commit -m \"Changement\"\ngit rebase main"
      },
      "branch-5": {
        "title": "Conflits de fusion",
        "description": "Quand deux branches modifient la **même partie** du même fichier, Git ne peut pas fusionner automatiquement. Vous obtenez un **conflit de fusion** : le fichier est marqué avec des marqueurs de conflit (**<<<<<<<**, **=======**, **>>>>>>>**) qui montrent les deux versions. Pour le résoudre : ouvrez le fichier, décidez du contenu final (garder une version, combiner les deux, ou modifier à la main), supprimez les marqueurs et la version que vous ne voulez pas, puis **git add** le fichier et **git commit** pour terminer la fusion. Dans cette simulation, pour ouvrir un fichier : tapez **edit nomfichier** dans le terminal ; l'éditeur s'ouvre en dessous—modifiez le contenu et cliquez sur Enregistrer. Les conflits sont normaux quand plusieurs personnes modifient les mêmes lignes ; les résoudre fait partie du travail en équipe.",
        "whyImportant": "En HN, plusieurs éditeurs ou jeux de données peuvent toucher les mêmes fichiers. Savoir lire les marqueurs de conflit et résoudre les conflits permet de fusionner des branches et d'intégrer le travail des autres en toute sérénité.",
        "whatToDo": [
          "**readme.txt** contient déjà un conflit. Tapez **cat readme.txt** pour voir les marqueurs de conflit",
          "Tapez **edit readme.txt** dans le terminal—l'éditeur s'ouvre en dessous. Supprimez les marqueurs de conflit et gardez le contenu souhaité (une version, l'autre, ou une combinaison). Cliquez sur **Enregistrer**",
          "Indexez le fichier résolu : **git add readme.txt**",
          "Terminez la fusion : **git commit -m \"Résoudre le conflit\"**",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "cat readme.txt\nedit readme.txt\ngit add readme.txt\ngit commit -m \"Résoudre le conflit\""
      },
      "gh-1": {
        "title": "Qu'est-ce que GitHub ?",
        "description": "GitHub est un site qui héberge des dépôts Git dans le cloud. Il vous donne une sauvegarde de votre dépôt, un historique visible en ligne, et des outils pour collaborer : d'autres peuvent cloner votre dépôt, proposer des changements (pull requests), et vous pouvez gérer les issues et la documentation. GitHub est très répandu dans l'open source et en HN.",
        "whyImportant": "Git est local ; GitHub est distant. Ensemble ils permettent de sauvegarder votre travail, de le partager et de collaborer. Beaucoup de projets HN publient leurs données et leur code sur GitHub pour la transparence et la réutilisation.",
        "whatToDo": [
          "Lire la section ci-dessus. (Vous pourrez créer un compte sur https://github.com plus tard depuis votre ordinateur.)",
          "Dans le terminal, taper **next** quand vous êtes prêt à continuer"
        ]
      },
      "gh-2": {
        "title": "Créer un dépôt sur GitHub",
        "description": "Sur GitHub, vous cliqueriez sur « New repository », choisiriez un nom (ex. mon-projet-hn) et obtiendriez une URL pour connecter votre dépôt local. Dans un vrai workflow on crée ce dépôt d'abord, puis on utilise son URL dans git remote et git push. Vous pourrez essayer sur github.com plus tard ; pour cette leçon on se concentre sur l'idée.",
        "whyImportant": "Le dépôt distant sur GitHub est l'endroit où votre historique local sera copié quand vous ferez un push. Le créer d'abord vous donne l'URL nécessaire pour l'étape suivante.",
        "whatToDo": [
          "Lire les étapes ci-dessus (vous pourrez créer un vrai dépôt sur GitHub plus tard depuis votre ordinateur)",
          "Dans le terminal, taper **next** quand c'est fait"
        ]
      },
      "gh-3": {
        "title": "Pousser votre code : git remote et git push",
        "description": "Pour envoyer vos commits locaux sur GitHub, vous liez votre dépôt au distant avec git remote add origin <URL>, puis vous poussez avec git push -u origin main. Ici vous pouvez exécuter ces commandes dans le terminal (une URL quelconque suffit pour la simulation) ; la leçon se valide quand vous exécutez git remote add ou git push.",
        "whyImportant": "Pousser (push) est la façon de sauvegarder et partager votre travail. Une fois configuré, ça devient une étape simple de votre routine.",
        "whatToDo": [
          "Dans le terminal : **git remote add origin https://github.com/you/repo.git** (n'importe quelle URL pour cette simulation)",
          "Puis : **git push -u origin main**",
          "La leçon se valide quand vous exécutez les commandes"
        ],
        "codeTemplate": "git remote add origin https://github.com/USER/REPO.git\ngit push -u origin main"
      },
      "gh-4": {
        "title": "Obtenir une copie : git clone et git pull",
        "description": "Pour obtenir une copie complète du dépôt de quelqu'un (ou du vôtre depuis un autre ordinateur), on utilise git clone <URL>. Quand vous clonez, Git crée un nouveau dossier (généralement nommé d'après le dépôt) et y place la copie complète—le dépôt cloné se trouve donc toujours dans son propre répertoire. Pour mettre à jour une copie existante, on lance git pull. Ici vous pouvez essayer ces commandes dans le terminal—ex. **git clone https://github.com/some/repo** ou **git pull**—pour voir la sortie simulée.",
        "whyImportant": "Clone et pull sont la façon de travailler avec des projets HN existants, de contribuer au travail d'autres, ou de synchroniser entre machines. Ils sont essentiels pour la collaboration.",
        "whatToDo": [
          "Dans le terminal, essayer **git clone https://github.com/some/repo** ou **git pull**",
          "Taper **next** quand c'est fait"
        ],
        "codeTemplate": "git clone https://github.com/USER/REPO.git\ngit pull"
      },
      "collab-1": {
        "title": "Collaboration et bonnes pratiques pour la HN",
        "description": "En pratique, les équipes HN utilisent des branches (lignes de travail séparées) et des pull requests (changements proposés pour revue) sur GitHub. Committez souvent avec des messages clairs ; poussez régulièrement pour sauvegarder. Utilisez un README pour expliquer le projet et, si pertinent, une licence pour que les autres sachent comment réutiliser vos données et votre code. Ces pratiques rendent votre projet compréhensible et citable.",
        "whyImportant": "De bonnes habitudes de contrôle de version rendent les projets HN reproductibles, transparents et plus faciles à transmettre ou publier. Elles s'alignent avec la science ouverte et les attentes des financeurs.",
        "whatToDo": [
          "Lire les conseils de collaboration et de bonnes pratiques ci-dessus",
          "Dans le terminal, taper **next** pour continuer"
        ]
      },
      "collab-2": {
        "title": "Prochaines étapes : installer Git, GitHub et l'authentification",
        "description": "Ce tutoriel s'exécute dans le navigateur. Pour utiliser Git et GitHub sur votre ordinateur : (1) **Installer Git** depuis https://git-scm.com/ (ou votre gestionnaire de paquets). (2) **Créer un compte GitHub** sur https://github.com si vous n'en avez pas. (3) **Configurer l'authentification** pour pouvoir pousser et tirer : soit des **clés SSH** (recommandé), soit un **jeton d'accès personnel** en HTTPS. La doc GitHub explique les deux : « Connecting to GitHub with SSH » et « Managing your personal access tokens ». Une fois Git installé et l'authentification configurée, vous pourrez cloner des dépôts, pousser votre travail et ouvrir des pull requests en ligne de commande ou avec une interface graphique.",
        "whyImportant": "Sans ces étapes, des commandes comme git push demanderont des identifiants ou échoueront. Quelques minutes de configuration sur votre machine débloquent tout ce que vous avez appris ici.",
        "whatToDo": [
          "Lire les étapes ci-dessus et mettre les liens en favoris",
          "Quand vous êtes prêt, taper **next** pour terminer le cours et voir votre certificat"
        ]
      }
    },
    "glossary": {
      "version control": "Système qui enregistre les changements des fichiers dans le temps pour pouvoir retrouver ou comparer des versions précises.",
      "repository": "Dossier géré par Git, contenant les fichiers du projet et tout l'historique des commits.",
      "dépôt": "Dossier géré par Git, contenant les fichiers du projet et tout l'historique des commits.",
      "repo": "Abréviation de dépôt (repository) : le dossier où Git conserve l'historique du projet.",
      "commit": "Photo du projet à un instant donné, avec un message et un identifiant unique. Les commits forment l'historique du projet.",
      "stage": "Marquer des fichiers comme prêts à être inclus dans le prochain commit (avec git add).",
      "staged": "Marqué comme prêt à être inclus dans le prochain commit (avec git add).",
      "push": "Envoyer vos commits locaux vers un dépôt distant (ex. sur GitHub).",
      "pull": "Récupérer et fusionner les changements d'un dépôt distant dans votre branche actuelle.",
      "clone": "Télécharger une copie d'un dépôt (avec son historique) depuis un serveur distant.",
      "clones": "Copies d'un dépôt (avec tout son historique) téléchargées depuis un serveur distant. On peut cloner une fois par machine ou par copie de travail.",
      "remote": "Version du dépôt hébergée ailleurs (ex. sur GitHub), souvent nommée origin.",
      "remotes": "Versions du dépôt hébergées ailleurs (ex. sur GitHub). Un dépôt peut avoir plusieurs remotes ; le défaut est souvent origin.",
      "origin": "Nom par défaut du dépôt distant (souvent sur GitHub) auquel votre dépôt local est relié.",
      "Git": "Outil gratuit et open source pour le contrôle de version sur votre ordinateur. Il conserve tout l'historique du projet dans un dépôt et fonctionne en local ; l'internet n'est nécessaire que pour partager ou sauvegarder (ex. via GitHub).",
      "GitHub": "Plateforme web qui héberge des dépôts Git et propose des outils de collaboration, issues et documentation.",
      "Digital Humanities": "Recherche et enseignement qui combinent méthodes numériques et disciplines des humanités ; implique souvent textes, jeux de données et code qui bénéficient du contrôle de version.",
      "DH": "Abréviation pour humanités numériques (Digital Humanities).",
      "HN": "Abréviation pour humanités numériques (Digital Humanities).",
      "branch": "Ligne de développement séparée dans un dépôt Git. On crée des branches pour tester des changements ou travailler sur des fonctionnalités sans toucher à la ligne principale.",
      "branches": "Lignes de développement séparées dans un dépôt Git. On crée des branches pour tester des changements ou travailler sur des fonctionnalités sans toucher à la ligne principale.",
      "merge": "Fusionner les commits d'une autre branche dans la branche courante (ex. git merge feature).",
      "merge conflict": "Quand deux branches modifient la même partie du même fichier, Git ne peut pas fusionner automatiquement. Le fichier est marqué avec des marqueurs de conflit (<<<<<<<, =======, >>>>>>>) ; vous éditez le fichier pour choisir le contenu final, supprimez les marqueurs, puis git add et git commit pour terminer la fusion.",
      "merge commit": "Commit qui enregistre la fusion de deux branches lorsqu'elles ont divergé (pas de fast-forward).",
      "fast-forward": "Lors d'une fusion, si la branche courante n'a pas divergé, Git avance simplement le pointeur ; aucun commit de merge n'est créé.",
      "squash merge": "Fusion qui apporte les changements d'une autre branche en un seul ensemble de changements en stage, sans commit de merge. On committe ensuite une fois, donc plusieurs commits en deviennent un.",
      "rebase": "Déplacer les commits de votre branche pour qu'ils reposent sur une autre branche, pour un historique linéaire. Commande : git rebase <branche>.",
      "pull request": "Sur GitHub, proposition de fusionner les changements d'une branche dans une autre, pour revue et discussion avant la fusion.",
      "README": "Fichier (souvent README.md) qui explique un projet : de quoi il s'agit, comment l'utiliser et contribuer. Souvent affiché sur GitHub.",
      "untracked": "Fichier que Git ne suit pas encore (pas dans la dernière photo ni en stage). git status les affiche.",
      ".gitignore": "Fichier à la racine du dépôt qui liste des motifs (un par ligne). Git ignore les fichiers correspondants : ils n'apparaissent pas comme non suivis et ne sont pas ajoutés avec git add .",
      "amend": "Modifier le dernier commit. git commit --amend -m \"Nouveau message\" remplace le message ; avec des changements en stage, les intègre dans ce commit.",
      "snapshot": "Copie du projet à un instant donné. Dans Git, chaque commit est une photo (snapshot) des fichiers suivis.",
      "main": "Nom par défaut de la branche principale dans beaucoup de dépôts Git. Les branches de fonctionnalités sont souvent fusionnées dans main.",
      "working tree": "Répertoire contenant les fichiers de votre projet tels qu'ils apparaissent sur le disque. Vos modifications sont dans l'arbre de travail jusqu'à ce que vous les mettiez en stage et committiez.",
      "conflict markers": "Les symboles que Git insère dans un fichier lors d'un conflit de fusion : <<<<<<<, =======, >>>>>>>. On les supprime en résolvant le conflit.",
      "checkout": "Passer sur une autre branche (ex. git checkout main) ou restaurer un fichier. git checkout -b <nom> crée et bascule sur une nouvelle branche.",
      "upstream": "La branche distante que votre branche courante suit. La définir (ex. avec git push -u origin main) relie votre branche au distant.",
      "license": "Fichier ou notice qui indique comment les autres peuvent utiliser, partager ou modifier le code et les données du projet.",
      "modified": "Fichier qui a été modifié depuis le dernier commit. git status les affiche (et indique s'ils sont en stage ou non).",
      "unstage": "Retirer un fichier du stage pour qu'il ne soit pas inclus dans le prochain commit (ex. git restore --staged <fichier>).",
      "open source": "Logiciel ou projet dont le code source (ou les données) est mis à disposition pour utilisation, modification et partage, souvent sous une licence.",
      "issues": "Sur GitHub, moyen de suivre les tâches, bugs et discussions d'un dépôt. Les autres peuvent ouvrir des issues pour proposer des changements ou signaler des problèmes.",
      "authentication": "Le processus pour prouver votre identité à GitHub afin de pousser et tirer. Méthodes courantes : clés SSH (recommandé) ou jeton d'accès personnel en HTTPS.",
      "SSH keys": "Moyen sécurisé de s'authentifier auprès de GitHub sans taper de mot de passe à chaque fois. Vous générez une paire de clés sur votre ordinateur et ajoutez la clé publique à votre compte GitHub.",
      "personal access token": "Identifiant de type mot de passe pour HTTPS qui permet de pousser et tirer depuis GitHub. Vous le créez dans les paramètres GitHub et l'utilisez à la place du mot de passe du compte.",
      "staging area": "L'endroit où Git garde les fichiers que vous avez ajoutés avec git add, prêts pour le prochain commit. Aussi appelé l'index. git status affiche ce qui est en stage.",
      "history": "La séquence des commits dans un dépôt. git log affiche l'historique ; chaque commit pointe vers son (ses) parent(s).",
      "local": "Sur votre propre ordinateur. Un dépôt local est la copie sur votre machine ; les commits locaux ne sont pas encore poussés vers un distant.",
      "tracked": "Fichier que Git suit—il était dans le dernier commit ou a été ajouté avec git add. Les fichiers non suivis ne sont pas encore dans le dépôt.",
      "commit message": "La courte description que vous donnez en committant (ex. avec -m \"Votre message\"). De bons messages aident à comprendre l'historique plus tard.",
      "workflow": "La façon dont vous utilisez Git au quotidien : modifier des fichiers, git add, git commit, et (pour partager) git push ou git pull.",
      "resolve": "Résoudre un conflit de fusion en éditant le fichier, en choisissant le contenu final, en supprimant les marqueurs de conflit, puis en mettant en stage et en committant.",
      "reproducibility": "Capacité pour d'autres (ou vous plus tard) de recréer ou citer un état précis d'un projet. Le contrôle de version favorise la reproductibilité.",
      "transparency": "Rendre l'historique des changements visible et traçable. Les financeurs et éditeurs attendent souvent le contrôle de version pour la transparence.",
      ".git": "Le dossier caché à l'intérieur de votre projet où Git stocke le dépôt (tous les commits, branches et métadonnées). Créé par git init.",
      "feature branch": "Branche utilisée pour développer une seule fonctionnalité ou modification, souvent fusionnée dans main une fois terminée. Garde main stable.",
      "diverged": "Quand deux branches ont des commits différents—ex. vous avez commité sur main pendant qu'un autre a commité sur une autre branche. La fusion peut créer un commit de merge.",
      "discard": "Annuler les changements non commités dans un fichier (ex. git restore <fichier>). Le fichier revient à la dernière version commitée. À utiliser avec précaution.",
      "linear history": "Historique où les commits suivent une seule ligne, sans commits de merge. Le rebase peut produire un historique linéaire.",
      "humanités numériques": "Recherche et enseignement qui combinent méthodes numériques et disciplines des humanités ; implique souvent textes, jeux de données et code qui bénéficient du contrôle de version.",
      "conflit de fusion": "Quand deux branches modifient la même partie du même fichier, Git ne peut pas fusionner automatiquement. Le fichier est marqué avec des marqueurs de conflit (<<<<<<<, =======, >>>>>>>) ; vous éditez le fichier pour choisir le contenu final, supprimez les marqueurs, puis git add et git commit pour terminer la fusion.",
      "marqueurs de conflit": "Les symboles que Git insère dans un fichier lors d'un conflit de fusion : <<<<<<<, =======, >>>>>>>. On les supprime en résolvant le conflit.",
      "arbre de travail": "Répertoire contenant les fichiers de votre projet tels qu'ils apparaissent sur le disque. Vos modifications sont dans l'arbre de travail jusqu'à ce que vous les mettiez en stage et committiez.",
      "branche principale": "Nom par défaut de la branche principale dans beaucoup de dépôts Git (souvent main). Les branches de fonctionnalités sont souvent fusionnées dans la branche principale.",
      "clés SSH": "Moyen sécurisé de s'authentifier auprès de GitHub sans taper de mot de passe à chaque fois. Vous générez une paire de clés sur votre ordinateur et ajoutez la clé publique à votre compte GitHub.",
      "jeton d'accès personnel": "Identifiant de type mot de passe pour HTTPS qui permet de pousser et tirer depuis GitHub. Vous le créez dans les paramètres GitHub et l'utilisez à la place du mot de passe du compte.",
      "historique": "La séquence des commits dans un dépôt. git log affiche l'historique ; chaque commit pointe vers son (ses) parent(s).",
      "reproductibilité": "Capacité pour d'autres (ou vous plus tard) de recréer ou citer un état précis d'un projet. Le contrôle de version favorise la reproductibilité.",
      "transparence": "Rendre l'historique des changements visible et traçable. Les financeurs et éditeurs attendent souvent le contrôle de version pour la transparence.",
      "résoudre": "Résoudre un conflit de fusion en éditant le fichier, en choisissant le contenu final, en supprimant les marqueurs de conflit, puis en mettant en stage et en committant.",
      "branche de fonctionnalité": "Branche utilisée pour développer une seule fonctionnalité ou modification, souvent fusionnée dans main une fois terminée. Garde main stable.",
      "historique linéaire": "Historique où les commits suivent une seule ligne, sans commits de merge. Le rebase peut produire un historique linéaire.",
      "annuler": "Annuler les changements non commités dans un fichier (ex. git restore <fichier>). Le fichier revient à la dernière version commitée. À utiliser avec précaution."
    },
    "cheatsheet": {
      "sections": [
        {
          "title": "1. Contrôle de version",
          "paragraphs": [
            "Définition : Une façon de sauvegarder et de suivre l'évolution de vos fichiers dans le temps. Un seul projet, un historique de chaque modification : qui a changé quoi, et quand. Vous pouvez revenir à n'importe quelle version antérieure.",
            "Pourquoi c'est important : Sans contrôle de version, il est facile de perdre du travail, d'écraser les changements d'un collègue ou d'oublier ce qu'on a modifié. Avec lui, vous avez un historique clair et pouvez collaborer en toute sécurité.",
            "Pour les humanités numériques : Les éditions, corpus, jeux de données et sites web impliquent souvent des équipes, des itérations sur des années, et le besoin de citer ou reproduire un état précis du projet. Beaucoup de financeurs et d'éditeurs attendent ou recommandent le contrôle de version pour la transparence et la reproductibilité."
          ]
        },
        {
          "title": "2. Bases de Git",
          "subsections": [
            {
              "title": "Qu'est-ce que Git ?",
              "list": [
                "Outil gratuit et open source pour le contrôle de version sur votre ordinateur.",
                "Fonctionne en local : tout l'historique est dans un dossier caché (un dépôt) à l'intérieur du projet.",
                "Pas besoin d'internet pour faire des commits—seulement pour partager ou sauvegarder (ex. avec GitHub)."
              ]
            },
            {
              "title": "Commandes essentielles",
              "items": [
                { "cmd": "git init", "desc": "Transformer le dossier actuel en dépôt Git" },
                { "cmd": "git add <fichier> ou git add .", "desc": "Mettre des fichiers en stage pour le prochain commit" },
                { "cmd": "git commit -m \"Votre message\"", "desc": "Créer une photo du projet avec un message court" },
                { "cmd": "git status", "desc": "Voir les fichiers modifiés, en stage et non suivis" },
                { "cmd": "git log", "desc": "Voir l'historique des commits" },
                { "cmd": "git log --oneline", "desc": "Vue compacte de l'historique (une ligne par commit)" }
              ]
            },
            {
              "title": "Workflow",
              "list": [
                "Créer ou modifier des fichiers.",
                "git add les fichiers à inclure.",
                "git commit -m \"Message clair et court\".",
                "Utiliser git status souvent pour éviter de committer les mauvais fichiers."
              ]
            },
            {
              "title": ".gitignore",
              "list": [
                "Fichier qui liste des motifs (un par ligne). Git ignore les fichiers correspondants : ils n'apparaissent pas comme non suivis et ne sont pas ajoutés avec git add .",
                "À utiliser pour : secrets, clés API, fichiers de build, config locale, caches, sauvegardes d'éditeur.",
                "Créer avec : edit .gitignore (dans le tutoriel) ou n'importe quel éditeur. Commiter .gitignore pour partager les règles."
              ]
            },
            {
              "title": "Corriger les erreurs",
              "items": [
                { "cmd": "git restore --staged <fichier>", "desc": "Retirer un fichier du stage (l'enlever du prochain commit)" },
                { "cmd": "git restore <fichier>", "desc": "Annuler les changements non commités dans ce fichier (à utiliser avec précaution)" },
                { "cmd": "git commit --amend -m \"Nouveau message\"", "desc": "Remplacer le message du dernier commit (ou y intégrer des changements en stage)" },
                { "cmd": "git reset --soft HEAD~1", "desc": "Annuler le dernier commit en gardant les changements en stage" }
              ]
            }
          ]
        },
        {
          "title": "3. Branches",
          "paragraphs": [
            "Branche : Ligne de développement séparée. Vous pouvez tester des changements ou travailler sur des fonctionnalités sans toucher à la ligne principale.",
            "Pourquoi : Essentiel pour expérimenter, travailler sur des fonctionnalités à part et collaborer. En HN, une branche peut servir pour une variante d'édition ou une mise à jour de jeu de données."
          ],
          "subsections": [
            {
              "title": "Commandes",
              "items": [
                { "cmd": "git branch", "desc": "Lister les branches (* = courante)" },
                { "cmd": "git checkout -b <nom>", "desc": "Créer et passer sur une nouvelle branche" },
                { "cmd": "git checkout <nom>", "desc": "Passer sur une branche existante" },
                { "cmd": "git merge <branche>", "desc": "Fusionner cette branche dans la branche courante" },
                { "cmd": "git merge --squash <branche>", "desc": "Apporter les changements de l'autre branche en un seul ensemble en stage ; vous commitez une fois (pas de commit de merge)" },
                { "cmd": "git rebase <branche>", "desc": "Déplacer vos commits pour qu'ils reposent sur l'autre branche (historique linéaire)" },
                { "cmd": "git branch -d <nom>", "desc": "Supprimer une branche fusionnée (pour garder la liste lisible)" }
              ]
            },
            {
              "title": "Conflits de fusion",
              "list": [
                "Quand deux branches modifient la même partie du même fichier, Git ne peut pas fusionner automatiquement.",
                "Le fichier est marqué avec des marqueurs de conflit : <<<<<<<, =======, >>>>>>>.",
                "Résoudre : Ouvrir le fichier, choisir le contenu final (garder une version, combiner ou modifier), supprimer les marqueurs et la version non voulue, puis git add le fichier et git commit."
              ]
            }
          ]
        },
        {
          "title": "4. GitHub",
          "paragraphs": [
            "Définition : Site qui héberge des dépôts Git dans le cloud. Sauvegarde, historique visible en ligne et outils pour collaborer : les autres peuvent cloner, proposer des changements (pull requests), et vous pouvez gérer les issues et la documentation.",
            "Lien avec Git : Git est local ; GitHub est distant. Ensemble ils permettent de sauvegarder, partager et collaborer."
          ],
          "subsections": [
            {
              "title": "Créer un dépôt sur GitHub",
              "list": [
                "Sur GitHub : New repository → choisir un nom (ex. mon-projet-hn) → vous obtenez une URL pour connecter votre dépôt local."
              ]
            },
            {
              "title": "Distant, push et pull",
              "items": [
                { "cmd": "git remote add origin <URL>", "desc": "Lier votre dépôt local au distant (ex. GitHub)" },
                { "cmd": "git push -u origin main", "desc": "Premier push : envoyer les commits et définir l'upstream" },
                { "cmd": "git push", "desc": "Envoyer vos commits vers le distant" },
                { "cmd": "git pull", "desc": "Récupérer et fusionner les changements depuis le distant" },
                { "cmd": "git clone <URL>", "desc": "Télécharger une copie complète d'un dépôt (crée un nouveau dossier)" }
              ]
            },
            {
              "title": "Conseil",
              "paragraphs": ["Faire git pull avant git push pour éviter les rejets quand d'autres ont poussé."]
            }
          ]
        },
        {
          "title": "5. Collaboration et bonnes pratiques",
          "list": [
            "Utiliser des branches pour des lignes de travail séparées ; utiliser les pull requests sur GitHub pour proposer et faire revue des changements avant de fusionner.",
            "Committer souvent avec des messages clairs et courts.",
            "Pousser régulièrement pour sauvegarder le travail.",
            "Ajouter un README (ex. README.md) pour expliquer le projet et comment l'utiliser ou contribuer.",
            "Ajouter une licence pour que les autres sachent comment réutiliser vos données et votre code.",
            "Une branche par fonctionnalité ou correctif, puis fusionner quand c'est prêt."
          ]
        },
        {
          "title": "6. Aide-mémoire des commandes",
          "subsections": [
            { "title": "Configuration", "code": "git config user.name \"Votre nom\"\ngit config user.email \"votre@email.com\"\ngit init" },
            { "title": "Workflow de base", "code": "git status\ngit add <fichier>   # ou git add .\ngit commit -m \"message\"\ngit log" },
            { "title": "Branches", "code": "git branch\ngit checkout -b <branche>\ngit checkout <branche>\ngit merge <branche>\ngit merge --squash <branche>\ngit rebase <branche>\ngit branch -d <branche>" },
            { "title": "Distant (GitHub)", "code": "git remote add origin <URL>\ngit push -u origin main\ngit push\ngit pull\ngit clone <URL>" },
            { "title": "Utile", "code": "git log --oneline\ngit remote -v\ngit restore --staged <fichier>\ngit restore <fichier>\ngit commit --amend -m \"Nouveau message\"" }
          ]
        },
        {
          "title": "7. Termes clés (glossaire)",
          "items": [
            { "cmd": "Dépôt (repository / repo)", "desc": "Dossier géré par Git ; contient les fichiers du projet et tout l'historique des commits." },
            { "cmd": "Commit", "desc": "Photo du projet à un instant donné, avec un message et un identifiant unique." },
            { "cmd": "Stage / staged", "desc": "Marquer des fichiers comme prêts pour le prochain commit avec git add." },
            { "cmd": "Remote / origin", "desc": "Version du dépôt hébergée ailleurs (ex. GitHub) ; origin est le nom par défaut." },
            { "cmd": "Push / Pull / Clone", "desc": "Push : envoyer les commits locaux vers un distant. Pull : récupérer et fusionner depuis le distant. Clone : télécharger une copie complète d'un dépôt." },
            { "cmd": "Branche / Merge", "desc": "Branche : ligne de développement séparée. Merge : fusionner une autre branche dans la branche courante." },
            { "cmd": "Conflit de fusion", "desc": "Même partie du même fichier modifiée dans deux branches ; on résout en éditant le fichier et en supprimant les marqueurs." },
            { "cmd": "Untracked / .gitignore", "desc": "Untracked : fichier que Git ne suit pas encore. .gitignore : fichier listant les motifs que Git doit ignorer." }
          ]
        },
        {
          "title": "8. Prochaines étapes (sur votre ordinateur)",
          "list": [
            "Installer Git : https://git-scm.com/ (ou votre gestionnaire de paquets).",
            "Créer un compte GitHub : https://github.com",
            "Configurer l'authentification pour pouvoir pousser et tirer : clés SSH (recommandé), ou jeton d'accès personnel en HTTPS. Voir la doc GitHub : « Connecting to GitHub with SSH » et « Managing your personal access tokens ».",
            "Une fois Git installé et l'authentification configurée, vous pourrez cloner des dépôts, pousser votre travail et ouvrir des pull requests en ligne de commande ou avec une interface graphique."
          ],
          "paragraphs": ["Tutoriel : https://humanities-data-lab.github.io/learn-git-and-github/"]
        }
      ]
    }
  }
}
